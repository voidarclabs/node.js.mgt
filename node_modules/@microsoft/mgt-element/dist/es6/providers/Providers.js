/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { EventDispatcher } from '../utils/EventDispatcher';
import { ProviderState } from './IProvider';
/**
 * Provides implementation for acquiring the necessary access token for calling the Microsoft Graph APIs.
 *
 * @export
 * @class Providers
 */
export class Providers {
    /**
     * returns the value of provider used globally. All components use this property to get a reference to the provider.
     *
     * @static
     * @type {IProvider}
     * @memberof Providers
     */
    static get globalProvider() {
        return this._globalProvider;
    }
    static set globalProvider(provider) {
        if (provider !== this._globalProvider) {
            if (this._globalProvider) {
                this._globalProvider.removeStateChangedHandler(this.handleProviderStateChanged);
                if (this._globalProvider.isMultiAccountSupportedAndEnabled) {
                    this._globalProvider.removeActiveAccountChangedHandler(this.handleActiveAccountChanged);
                }
            }
            if (provider) {
                provider.onStateChanged(this.handleProviderStateChanged);
                if (provider.isMultiAccountSupportedAndEnabled) {
                    provider.onActiveAccountChanged(this.handleActiveAccountChanged);
                }
            }
            this._globalProvider = provider;
            this._eventDispatcher.fire(ProvidersChangedState.ProviderChanged);
        }
    }
    /**
     * Fires event when Provider changes state
     *
     * @static
     * @param {EventHandler<ProvidersChangedState>} event
     * @memberof Providers
     */
    static onProviderUpdated(event) {
        this._eventDispatcher.add(event);
    }
    /**
     * Remove event handler
     *
     * @static
     * @param {EventHandler<ProvidersChangedState>} event
     * @memberof Providers
     */
    static removeProviderUpdatedListener(event) {
        this._eventDispatcher.remove(event);
    }
    /**
     * Fires event when Provider changes state
     *
     * @static
     * @param {EventHandler<ProvidersChangedState>} event
     * @memberof Providers
     */
    static onActiveAccountChanged(event) {
        this._activeAccountChangedDispatcher.add(event);
    }
    /**
     * Remove event handler
     *
     * @static
     * @param {EventHandler<ProvidersChangedState>} event
     * @memberof Providers
     */
    static removeActiveAccountChangedListener(event) {
        this._activeAccountChangedDispatcher.remove(event);
    }
    /**
     * Gets the current signed in user
     *
     * @static
     * @memberof Providers
     */
    static me() {
        if (!this.client) {
            this._mePromise = null;
            return null;
        }
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        if (!this._mePromise) {
            this._mePromise = this.getMe();
        }
        return this._mePromise;
    }
    /**
     * Get current signed in user details
     *
     * @private
     * @static
     * @return {*}  {Promise<User>}
     * @memberof Providers
     */
    static getMe() {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                const response = (yield this.client.api('me').get());
                if (response === null || response === void 0 ? void 0 : response.id) {
                    return response;
                }
            }
            catch (_a) {
                // no-op
            }
            return null;
        });
    }
    /**
     * Gets the cache ID, creates one if it does not exist
     *
     * @static
     * @memberof Providers
     */
    static getCacheId() {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            if (this._cacheId) {
                return this._cacheId;
            }
            if (((_a = Providers.globalProvider) === null || _a === void 0 ? void 0 : _a.state) === ProviderState.SignedIn) {
                if (!this._cacheId) {
                    const client = this.client;
                    if (client) {
                        try {
                            this._cacheId = yield this.createCacheId();
                        }
                        catch (_b) {
                            // no-op
                        }
                    }
                }
            }
            return this._cacheId;
        });
    }
    /**
     * Unset the cache ID
     *
     * @static
     * @memberof Providers
     */
    static unsetCacheId() {
        this._cacheId = null;
        this._mePromise = null;
    }
    /**
     * Create cache ID
     *
     * @private
     * @static
     * @return {*}  {Promise<string>}
     * @memberof Providers
     */
    static createCacheId() {
        return __awaiter(this, void 0, void 0, function* () {
            if (Providers.globalProvider.isMultiAccountSupportedAndEnabled) {
                const cacheId = this.createCacheIdWithAccountDetails();
                if (cacheId) {
                    return cacheId;
                }
            }
            return yield this.createCacheIdWithUserDetails();
        });
    }
    /**
     * Create a cache ID with user userID and principal name
     *
     * @static
     * @param {User} response
     * @return {*}
     * @memberof Providers
     */
    static createCacheIdWithUserDetails() {
        return __awaiter(this, void 0, void 0, function* () {
            const response = yield this.me();
            if (response === null || response === void 0 ? void 0 : response.id) {
                return response.id + '-' + response.userPrincipalName;
            }
            else
                return null;
        });
    }
    /**
     * Create cache ID with tenant ID and user ID
     *
     * @private
     * @static
     * @return {*}  {string}
     * @memberof Providers
     */
    static createCacheIdWithAccountDetails() {
        const user = Providers.globalProvider.getActiveAccount();
        if (user.tenantId && user.id) {
            return user.tenantId + user.id;
        }
        else
            return null;
    }
    /**
     * Gets the current graph client
     *
     * @readonly
     * @static
     * @type {Client}
     * @memberof Providers
     */
    static get client() {
        if (Providers.globalProvider && Providers.globalProvider.state === ProviderState.SignedIn) {
            return Providers.globalProvider.graph.client;
        }
        return null;
    }
}
Providers._eventDispatcher = new EventDispatcher();
Providers._activeAccountChangedDispatcher = new EventDispatcher();
Providers.handleProviderStateChanged = () => {
    if (!Providers.globalProvider || Providers.globalProvider.state !== ProviderState.SignedIn) {
        // clear current signed in user info
        Providers._mePromise = null;
    }
    Providers._eventDispatcher.fire(ProvidersChangedState.ProviderStateChanged);
};
Providers.handleActiveAccountChanged = () => {
    Providers.unsetCacheId();
    Providers._activeAccountChangedDispatcher.fire(null);
};
/**
 * on Provider Change State
 *
 * @export
 * @enum {number}
 */
export var ProvidersChangedState;
(function (ProvidersChangedState) {
    /**
     * ProviderChanged = 0
     */
    ProvidersChangedState[ProvidersChangedState["ProviderChanged"] = 0] = "ProviderChanged";
    /**
     * ProviderStateChanged = 1
     */
    ProvidersChangedState[ProvidersChangedState["ProviderStateChanged"] = 1] = "ProviderStateChanged";
})(ProvidersChangedState || (ProvidersChangedState = {}));
//# sourceMappingURL=Providers.js.map