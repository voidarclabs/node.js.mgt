{"version":3,"file":"equals.js","sourceRoot":"src/","sources":["utils/equals.ts"],"names":[],"mappings":"AAAA;;;;;GAKG;AAEH;;;;;;GAMG;AACH,MAAM,CAAC,MAAM,MAAM,GAAG,CAAC,EAAW,EAAE,EAAW,EAAE,EAAE;IACjD,OAAO,cAAc,CAAC,EAAE,EAAE,EAAE,EAAE,IAAI,GAAG,EAAE,CAAC,CAAC;AAC3C,CAAC,CAAC;AAEF;;;;;;GAMG;AACH,MAAM,cAAc,GAAG,CAAC,EAAW,EAAE,EAAW,EAAE,IAAkB,EAAE,EAAE;IACtE,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAW,CAAC;IAC7D,MAAM,OAAO,GAAG,MAAM,CAAC,SAAS,CAAC,QAAQ,CAAC,IAAI,CAAC,EAAE,CAAW,CAAC;IAC7D,IACE,OAAO,EAAE,KAAK,QAAQ;QACtB,OAAO,EAAE,KAAK,QAAQ;QACtB,OAAO,KAAK,OAAO;QACnB,OAAO,KAAK,iBAAiB;QAC7B,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EACb;QACA,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACb,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE;YAClB,sEAAsE;YACtE,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;gBACvC,OAAO,KAAK,CAAC;aACd;SACF;QACD,KAAK,MAAM,CAAC,IAAI,EAAE,EAAE;YAClB,IAAI,CAAC,MAAM,CAAC,SAAS,CAAC,cAAc,CAAC,IAAI,CAAC,EAAE,EAAE,CAAC,CAAC,EAAE;gBAChD,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;KACb;IACD,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,KAAK,CAAC,OAAO,CAAC,EAAE,CAAC,IAAI,CAAC,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,EAAE;QAC3D,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,CAAC;QACb,IAAI,EAAE,CAAC,MAAM,KAAK,EAAE,CAAC,MAAM,EAAE;YAC3B,OAAO,KAAK,CAAC;SACd;QACD,KAAK,IAAI,CAAC,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,CAAC,MAAM,EAAE,CAAC,EAAE,EAAE;YAClC,IAAI,CAAC,cAAc,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,EAAE,CAAC,CAAC,CAAC,EAAE,IAAI,CAAC,EAAE;gBACvC,OAAO,KAAK,CAAC;aACd;SACF;QACD,OAAO,IAAI,CAAC;KACb;IACD,+EAA+E;IAC/E,OAAO,EAAE,KAAK,EAAE,CAAC;AACnB,CAAC,CAAC;AAEF;;;;;;;;;GASG;AACH,MAAM,CAAC,MAAM,cAAc,GAAG,CAAI,IAAS,EAAE,IAAS,EAAE,EAAE;IACxD,IAAI,IAAI,KAAK,IAAI,EAAE;QACjB,OAAO,IAAI,CAAC;KACb;IAED,IAAI,CAAC,IAAI,IAAI,CAAC,IAAI,EAAE;QAClB,OAAO,KAAK,CAAC;KACd;IAED,IAAI,IAAI,CAAC,MAAM,KAAK,IAAI,CAAC,MAAM,EAAE;QAC/B,OAAO,KAAK,CAAC;KACd;IAED,IAAI,IAAI,CAAC,MAAM,KAAK,CAAC,EAAE;QACrB,OAAO,IAAI,CAAC;KACb;IAED,MAAM,OAAO,GAAG,IAAI,GAAG,CAAC,IAAI,CAAC,CAAC;IAE9B,KAAK,MAAM,CAAC,IAAI,IAAI,EAAE;QACpB,IAAI,CAAC,OAAO,CAAC,GAAG,CAAC,CAAC,CAAC,EAAE;YACnB,OAAO,KAAK,CAAC;SACd;KACF;IAED,OAAO,IAAI,CAAC;AACd,CAAC,CAAC","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\n/**\n * Crude implementation of equivalence between the two specified arguments.\n *\n * The primary intent of this function is for comparing data contexts, which\n * are expected to be object literals with potentially nested structures and\n * where leaf values are primitives.\n */\nexport const equals = (o1: unknown, o2: unknown) => {\n  return equalsInternal(o1, o2, new Set());\n};\n\n/**\n * Not exposed as it would undesirably leak implementation detail (`refs` argument).\n *\n * The `refs` argument is used to avoid infinite recursion due to circular references.\n *\n * @see equals\n */\nconst equalsInternal = (o1: unknown, o2: unknown, refs: Set<unknown>) => {\n  const o1Label = Object.prototype.toString.call(o1) as string;\n  const o2Label = Object.prototype.toString.call(o2) as string;\n  if (\n    typeof o1 === 'object' &&\n    typeof o2 === 'object' &&\n    o1Label === o2Label &&\n    o1Label === '[object Object]' &&\n    !refs.has(o1)\n  ) {\n    refs.add(o1);\n    for (const k in o1) {\n      // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access\n      if (!equalsInternal(o1[k], o2[k], refs)) {\n        return false;\n      }\n    }\n    for (const k in o2) {\n      if (!Object.prototype.hasOwnProperty.call(o1, k)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (Array.isArray(o1) && Array.isArray(o2) && !refs.has(o1)) {\n    refs.add(o1);\n    if (o1.length !== o2.length) {\n      return false;\n    }\n    for (let i = 0; i < o1.length; i++) {\n      if (!equalsInternal(o1[i], o2[i], refs)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  // Everything else requires strict equality (e.g. primitives, functions, dates)\n  return o1 === o2;\n};\n\n/**\n * Compares two arrays if the elements are equals\n * Should be used for arrays of primitive types\n *\n * @export\n * @template T the type of the elements in the array (should be primitive)\n * @param {T[]} arr1\n * @param {T[]} arr2\n * @returns true if both arrays contain the same items or if both arrays are null or empty\n */\nexport const arraysAreEqual = <T>(arr1: T[], arr2: T[]) => {\n  if (arr1 === arr2) {\n    return true;\n  }\n\n  if (!arr1 || !arr2) {\n    return false;\n  }\n\n  if (arr1.length !== arr2.length) {\n    return false;\n  }\n\n  if (arr1.length === 0) {\n    return true;\n  }\n\n  const setArr1 = new Set(arr1);\n\n  for (const i of arr2) {\n    if (!setArr1.has(i)) {\n      return false;\n    }\n  }\n\n  return true;\n};\n"]}