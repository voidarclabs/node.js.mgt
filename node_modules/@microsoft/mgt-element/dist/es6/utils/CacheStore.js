/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { openDB } from 'idb';
import { Providers } from '../providers/Providers';
import { dbListKey } from './CacheService';
/**
 * Represents a store in the cache
 *
 * @class CacheStore
 * @template T
 */
export class CacheStore {
    constructor(schema, store) {
        if (!(store in schema.stores)) {
            throw Error('"store" must be defined in the "schema"');
        }
        this.schema = schema;
        this.store = store;
    }
    /**
     * gets value from cache for the given key
     *
     * @param {string} key
     * @returns {Promise<T>}
     * @memberof Cache
     */
    getValue(key) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!window.indexedDB) {
                return null;
            }
            try {
                const db = yield this.getDb();
                return db.get(this.store, key);
            }
            catch (e) {
                return null;
            }
        });
    }
    /**
     * inserts value into cache for the given key
     *
     * @param {string} key
     * @param {T} item
     * @returns
     * @memberof Cache
     */
    putValue(key, item) {
        return __awaiter(this, void 0, void 0, function* () {
            if (!window.indexedDB) {
                return;
            }
            try {
                yield (yield this.getDb()).put(this.store, Object.assign(Object.assign({}, item), { timeCached: Date.now() }), key);
            }
            catch (e) {
                return;
            }
        });
    }
    /**
     * Clears the store of all stored values
     *
     * @returns
     * @memberof Cache
     */
    clearStore() {
        return __awaiter(this, void 0, void 0, function* () {
            if (!window.indexedDB) {
                return;
            }
            try {
                yield (yield this.getDb()).clear(this.store);
            }
            catch (e) {
                return;
            }
        });
    }
    /**
     * Returns the name of the parent DB that the cache store belongs to
     */
    getDBName() {
        return __awaiter(this, void 0, void 0, function* () {
            const id = yield Providers.getCacheId();
            if (id) {
                return `mgt-${this.schema.name}` + `-${id}`;
            }
        });
    }
    getDb() {
        return __awaiter(this, void 0, void 0, function* () {
            const dbName = yield this.getDBName();
            if (dbName) {
                return openDB(dbName, this.schema.version, {
                    // eslint-disable-next-line @typescript-eslint/no-unused-vars
                    upgrade: (db, _oldVersion, _newVersion, _transaction) => {
                        const dbArray = JSON.parse(localStorage.getItem(dbListKey)) || [];
                        if (!dbArray.includes(dbName)) {
                            dbArray.push(dbName);
                        }
                        localStorage.setItem(dbListKey, JSON.stringify(dbArray));
                        for (const storeName in this.schema.stores) {
                            if (Object.prototype.hasOwnProperty.call(this.schema.stores, storeName) &&
                                !db.objectStoreNames.contains(storeName)) {
                                db.createObjectStore(storeName);
                            }
                        }
                    }
                });
            }
        });
    }
}
//# sourceMappingURL=CacheStore.js.map