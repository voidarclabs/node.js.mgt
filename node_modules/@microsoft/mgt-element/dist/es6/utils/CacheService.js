/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { Providers } from '../providers/Providers';
import { ProviderState } from '../providers/IProvider';
import { CacheStore } from './CacheStore';
/**
 * Localstorage key for storing names of cache databases
 *
 * @type {string}
 *
 */
export const dbListKey = 'mgt-db-list';
/**
 * class in charge of managing all the caches and their stores
 *
 * @export
 * @class CacheService
 */
export class CacheService {
    /**
     * Looks for existing cache, otherwise creates a new one
     *
     * @static
     * @template T
     * @param {CacheSchema} schema
     * @param {string} storeName
     * @returns {CacheStore<T>}
     * @memberof CacheService
     */
    static getCache(schema, storeName) {
        const key = `${schema.name}/${storeName}`;
        if (!this.isInitialized) {
            this.init();
        }
        if (!this.cacheStore.has(storeName)) {
            this.cacheStore.set(key, new CacheStore(schema, storeName));
        }
        return this.cacheStore.get(key);
    }
    /**
     * Clears cache for a single user when ID is passed
     *
     * @static
     * @param {string} id
     * @memberof CacheService
     */
    static clearCacheById(id) {
        const work = [];
        const oldDbArray = JSON.parse(localStorage.getItem(dbListKey));
        if (oldDbArray) {
            const newDbArray = [];
            oldDbArray.forEach(x => {
                if (x.includes(id)) {
                    work.push(new Promise((resolve, reject) => {
                        const delReq = indexedDB.deleteDatabase(x);
                        delReq.onsuccess = () => resolve();
                        delReq.onerror = () => {
                            console.error(`ðŸ¦’: ${delReq.error.name} occurred deleting cache: ${x}`, delReq.error.message);
                            reject();
                        };
                    }));
                }
                else {
                    newDbArray.push(x);
                }
            });
            if (newDbArray.length > 0) {
                localStorage.setItem(dbListKey, JSON.stringify(newDbArray));
            }
            else {
                localStorage.removeItem(dbListKey);
            }
        }
        return Promise.all(work);
    }
    /**
     * returns the cacheconfig object
     *
     * @readonly
     * @static
     * @type {CacheConfig}
     * @memberof CacheService
     */
    static get config() {
        return this.cacheConfig;
    }
    /**
     * Checks for current sign in state and see if it has changed from signed-in to signed out
     *
     *
     * @private
     * @static
     * @memberof CacheService
     */
    static init() {
        let previousState;
        if (Providers.globalProvider) {
            previousState = Providers.globalProvider.state;
        }
        // eslint-disable-next-line @typescript-eslint/no-misused-promises
        Providers.onProviderUpdated(() => __awaiter(this, void 0, void 0, function* () {
            if (previousState === ProviderState.SignedIn && Providers.globalProvider.state === ProviderState.SignedOut) {
                const id = yield Providers.getCacheId();
                if (id !== null) {
                    yield this.clearCacheById(id);
                }
            }
            previousState = Providers.globalProvider.state;
        }));
        this.isInitialized = true;
    }
}
CacheService.cacheStore = new Map();
CacheService.isInitialized = false;
CacheService.cacheConfig = {
    defaultInvalidationPeriod: 3600000,
    groups: {
        invalidationPeriod: null,
        isEnabled: true
    },
    isEnabled: true,
    people: {
        invalidationPeriod: null,
        isEnabled: true
    },
    photos: {
        invalidationPeriod: null,
        isEnabled: true
    },
    presence: {
        invalidationPeriod: 300000,
        isEnabled: true
    },
    users: {
        invalidationPeriod: null,
        isEnabled: true
    },
    response: {
        invalidationPeriod: null,
        isEnabled: true
    },
    files: {
        invalidationPeriod: null,
        isEnabled: true
    },
    fileLists: {
        invalidationPeriod: null,
        isEnabled: true
    }
};
//# sourceMappingURL=CacheService.js.map