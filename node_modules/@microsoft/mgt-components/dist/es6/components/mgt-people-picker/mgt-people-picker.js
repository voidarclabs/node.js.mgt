/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { html } from 'lit';
import { property, state } from 'lit/decorators.js';
import { repeat } from 'lit/directives/repeat.js';
import { findGroups, getGroupsForGroupIds, GroupType, getGroup, findGroupsFromGroupIds } from '../../graph/graph.groups';
import { findPeople, getPeople, PersonType, UserType } from '../../graph/graph.people';
import { findUsers, findGroupMembers, findUsersFromGroupIds, getUser, getUsersForUserIds, getUsers } from '../../graph/graph.user';
import { ViewType } from '../../graph/types';
import { Providers, ProviderState, MgtTemplatedComponent, arraysAreEqual, mgtHtml, customElement } from '@microsoft/mgt-element';
import '../../styles/style-helper';
import '../sub-components/mgt-spinner/mgt-spinner';
import { debounce, isValidEmail } from '../../utils/Utils';
import { MgtPerson, defaultPersonProperties } from '../mgt-person/mgt-person';
import { PersonCardInteraction } from '../PersonCardInteraction';
import { styles } from './mgt-people-picker-css';
import { SvgIcon, getSvg } from '../../utils/SvgHelper';
import { fluentTextField, fluentCard } from '@fluentui/web-components';
import { registerFluentComponents } from '../../utils/FluentComponents';
import { strings } from './strings';
import { isGraphError } from '../../graph/isGraphError';
registerFluentComponents(fluentTextField, fluentCard);
export { GroupType } from '../../graph/graph.groups';
export { PersonType, UserType } from '../../graph/graph.people';
/**
 * Web component used to search for people from the Microsoft Graph
 *
 * @export
 * @class MgtPicker
 * @extends {MgtTemplatedComponent}
 *
 * @fires {CustomEvent<IDynamicPerson[]>} selectionChanged - Fired when set of selected people changes
 *
 * @cssprop --people-picker-selected-option-background-color - {Color} the background color of the selected person.
 * @cssprop --people-picker-selected-option-highlight-background-color - {Color} the background color of the selected person when you select it for copy/cut.
 * @cssprop --people-picker-dropdown-background-color - {Color} the background color of the dropdown card.
 * @cssprop --people-picker-dropdown-result-background-color - {Color} the background color of the dropdown result.
 * @cssprop --people-picker-dropdown-result-hover-background-color - {Color} the background color of the dropdown result on hover.
 * @cssprop --people-picker-dropdown-result-focus-background-color - {Color} the background color of the dropdown result on focus.
 * @cssprop --people-picker-no-results-text-color - {Color} the no results found text color.
 * @cssprop --people-picker-input-background - {Color} the input background color.
 * @cssprop --people-picker-input-border-color - {Color} the input border color.
 * @cssprop --people-picker-input-hover-background - {Color} the input background color when you hover.
 * @cssprop --people-picker-input-hover-border-color - {Color} the input border color when you hover
 * @cssprop --people-picker-input-focus-background - {Color} the input background color when you focus.
 * @cssprop --people-picker-input-focus-border-color - {Color} the input border color when you focus.
 * @cssprop --people-picker-input-placeholder-focus-text-color - {Color} the placeholder text color when you focus.
 * @cssprop --people-picker-input-placeholder-hover-text-color - {Color} the placeholder text color when you hover.
 * @cssprop --people-picker-input-placeholder-text-color - {Color} the placeholder text color.
 * @cssprop --people-picker-search-icon-color - {Color} the search icon color
 * @cssprop --people-picker-remove-selected-close-icon-color - {Color} the remove selected person close icon color.
 */
let MgtPeoplePicker = class MgtPeoplePicker extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * user the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * The strings to be used for localizing the component.
     *
     * @readonly
     * @protected
     * @memberof MgtPeoplePicker
     */
    get strings() {
        return strings;
    }
    /**
     * Gets the flyout element
     *
     * @protected
     * @type {MgtFlyout}
     * @memberof MgtLogin
     */
    get flyout() {
        return this.renderRoot.querySelector('.flyout');
    }
    /**
     * Gets the input element
     *
     * @protected
     * @type {MgtFlyout}
     * @memberof MgtLogin
     */
    get input() {
        return this.renderRoot.querySelector('fluent-text-field');
    }
    /**
     * value determining if search is filtered to a group.
     *
     * @type {string}
     */
    get groupId() {
        return this._groupId;
    }
    set groupId(value) {
        if (this._groupId === value) {
            return;
        }
        this._groupId = value;
        void this.requestStateUpdate(true);
    }
    /**
     * array of groups for search to be filtered by.
     *
     * @type {string[]}
     */
    get groupIds() {
        return this._groupIds;
    }
    set groupIds(value) {
        if (arraysAreEqual(this._groupIds, value)) {
            return;
        }
        this._groupIds = value;
        void this.requestStateUpdate(true);
    }
    /**
     * value determining if search is filtered to a group.
     *
     * @type {PersonType}
     */
    get type() {
        return this._type;
    }
    set type(value) {
        if (this._type === value) {
            return;
        }
        this._type = value;
        void this.requestStateUpdate(true);
    }
    /**
     * type of group to search for - requires personType to be
     * set to "Group" or "All"
     *
     * @type {GroupType}
     */
    get groupType() {
        return this._groupType;
    }
    set groupType(value) {
        if (this._groupType === value) {
            return;
        }
        this._groupType = value;
        void this.requestStateUpdate(true);
    }
    /**
     * The type of user to search for. Default is any.
     *
     * @readonly
     * @type {UserType}
     * @memberof MgtPeoplePicker
     */
    get userType() {
        return this._userType;
    }
    set userType(value) {
        if (this._userType === value) {
            return;
        }
        this._userType = value;
        void this.requestStateUpdate(true);
    }
    /**
     * whether the return should contain a flat list of all nested members
     *
     * @type {boolean}
     */
    get transitiveSearch() {
        return this._transitiveSearch;
    }
    set transitiveSearch(value) {
        if (this.transitiveSearch !== value) {
            this._transitiveSearch = value;
            void this.requestStateUpdate(true);
        }
    }
    /**
     * containing object of IDynamicPerson.
     *
     * @type {IDynamicPerson[]}
     */
    get people() {
        return this._people;
    }
    set people(value) {
        if (!arraysAreEqual(this._people, value)) {
            this._people = value;
            void this.requestStateUpdate(true);
        }
    }
    /**
     * determining how many people to show in list.
     *
     * @type {number}
     */
    get showMax() {
        return this._showMax;
    }
    set showMax(value) {
        if (value !== this._showMax) {
            this._showMax = value;
            void this.requestStateUpdate(true);
        }
    }
    /**
     * array of user picked people.
     *
     * @type {IDynamicPerson[]}
     */
    get selectedPeople() {
        return this._selectedPeople;
    }
    set selectedPeople(value) {
        if (!value)
            value = [];
        if (!arraysAreEqual(this._selectedPeople, value)) {
            this._selectedPeople = value;
            this.requestUpdate();
        }
    }
    /**
     * array of people to be selected upon initialization
     *
     * @type {string[]}
     * @memberof MgtPeoplePicker
     */
    get defaultSelectedUserIds() {
        return this._defaultSelectedUserIds;
    }
    set defaultSelectedUserIds(value) {
        if (!arraysAreEqual(this._defaultSelectedUserIds, value)) {
            this._defaultSelectedUserIds = value;
            void this.requestStateUpdate(true);
        }
    }
    /**
     * array of groups to be selected upon initialization
     *
     * @type {string[]}
     * @memberof MgtPeoplePicker
     */
    get defaultSelectedGroupIds() {
        return this._defaultSelectedGroupIds;
    }
    set defaultSelectedGroupIds(value) {
        if (!arraysAreEqual(this._defaultSelectedGroupIds, value)) {
            this._defaultSelectedGroupIds = value;
            void this.requestStateUpdate(true);
        }
    }
    /**
     * Array of the only users to be searched.
     *
     * @type {string[]}
     * @memberof MgtPeoplePicker
     */
    get userIds() {
        return this._userIds;
    }
    set userIds(value) {
        if (arraysAreEqual(this._userIds, value)) {
            return;
        }
        this._userIds = value;
        void this.requestStateUpdate(true);
    }
    /**
     * Filters that can be set on the user properties query.
     */
    get userFilters() {
        return this._userFilters;
    }
    set userFilters(value) {
        this._userFilters = value;
        void this.requestStateUpdate(true);
    }
    /**
     * Filters that can be set on the people query properties.
     */
    get peopleFilters() {
        return this._peopleFilters;
    }
    set peopleFilters(value) {
        this._peopleFilters = value;
        void this.requestStateUpdate(true);
    }
    /**
     * Filters that can be set on the group query properties.
     */
    get groupFilters() {
        return this._groupFilters;
    }
    set groupFilters(value) {
        this._groupFilters = value;
        void this.requestStateUpdate(true);
    }
    /**
     * Get the scopes required for people picker
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtPeoplePicker
     */
    static get requiredScopes() {
        return [
            ...new Set(['user.read.all', 'people.read', 'group.read.all', 'user.readbasic.all', ...MgtPerson.requiredScopes])
        ];
    }
    constructor() {
        super();
        this._type = PersonType.person;
        this._groupType = GroupType.any;
        this._userType = UserType.any;
        this._selectedPeople = [];
        // tracking of user arrow key input for selection
        this._arrowSelectionCount = -1;
        this.defaultSelectedUsers = [];
        this.defaultSelectedGroups = [];
        // List of users highlighted for copy/cut-pasting
        this._highlightedUsers = [];
        // current user index to the left of the highlighted users
        this._currentHighlightedUserPos = 0;
        /**
         * Checks if the input is focused.
         */
        this._isFocused = false;
        /**
         * Switch to determine if a typed email can be set.
         */
        this._setAnyEmail = false;
        // handle input click
        this.handleInputClick = () => {
            if (!this.flyout.isOpen) {
                this.handleUserSearch();
            }
        };
        // handle input focus
        this.gainedFocus = () => {
            this.clearHighlighted();
            this._isFocused = true;
            void this.loadState();
            this.showFlyout();
        };
        // handle input blur
        this.lostFocus = () => {
            this._isFocused = false;
            if (this.input) {
                this.input.setAttribute('aria-activedescendant', '');
            }
            const peopleList = this.renderRoot.querySelector('.people-list');
            if (peopleList) {
                for (const el of peopleList.children) {
                    el.classList.remove('focused');
                    el.setAttribute('aria-selected', 'false');
                }
            }
            this.requestUpdate();
        };
        /**
         * Handles input from the key up events on the keyboard.
         */
        this.onUserKeyUp = (event) => {
            const keyName = event.key;
            const isCmdOrCtrlKey = event.getModifierState('Control') || event.getModifierState('Meta');
            const isPaste = isCmdOrCtrlKey && keyName === 'v';
            const isArrowKey = ['ArrowDown', 'ArrowRight', 'ArrowUp', 'ArrowLeft'].includes(keyName);
            if ((!isPaste && isCmdOrCtrlKey) || isArrowKey) {
                if (isCmdOrCtrlKey || ['ArrowLeft', 'ArrowRight'].includes(keyName)) {
                    // Only hide the flyout when you're doing selections with Left/Right Arrow key
                    this.hideFlyout();
                }
                if (keyName === 'ArrowDown') {
                    if (!this.flyout.isOpen && this._isFocused) {
                        this.handleUserSearch();
                    }
                }
                return;
            }
            if (['Tab', 'Enter', 'Shift'].includes(keyName))
                return;
            if (keyName === 'Escape') {
                this.clearInput();
                this._foundPeople = [];
                this._arrowSelectionCount = -1;
                return;
            }
            if (keyName === 'Backspace' && this.userInput.length === 0 && this.selectedPeople.length > 0) {
                this.clearHighlighted();
                // remove last person in selected list
                this.selectedPeople = this.selectedPeople.splice(0, this.selectedPeople.length - 1);
                void this.loadState();
                this.hideFlyout();
                // fire selected people changed event
                this.fireCustomEvent('selectionChanged', this.selectedPeople);
                return;
            }
            if ([';', ','].includes(keyName)) {
                if (this.allowAnyEmail) {
                    this._setAnyEmail = true;
                    event.preventDefault();
                    event.stopPropagation();
                }
                return;
            }
        };
        this.onUserInput = (event) => {
            const input = event.target;
            this.userInput = input.value;
            if (this.userInput) {
                const validEmail = isValidEmail(this.userInput);
                if (validEmail && this.allowAnyEmail) {
                    if (this._setAnyEmail) {
                        this.handleAnyEmail();
                    }
                }
                else {
                    this.handleUserSearch();
                }
                this._setAnyEmail = false;
            }
        };
        /**
         * Tracks event on user search (keydown)
         *
         * @param event - event tracked on user input (keydown)
         */
        this.onUserKeyDown = (event) => {
            const keyName = event.key;
            const selectedList = this.renderRoot.querySelector('.selected-list');
            const isCmdOrCtrlKey = event.getModifierState('Control') || event.getModifierState('Meta');
            if (isCmdOrCtrlKey && selectedList) {
                const selectedPeople = selectedList.querySelectorAll('mgt-person.selected-list-item-person');
                this.hideFlyout();
                if (isCmdOrCtrlKey && keyName === 'ArrowLeft') {
                    this._currentHighlightedUserPos =
                        (this._currentHighlightedUserPos - 1 + selectedPeople.length) % selectedPeople.length;
                    if (this._currentHighlightedUserPos >= 0 && !Number.isNaN(this._currentHighlightedUserPos)) {
                        this._highlightedUsers.push(selectedPeople[this._currentHighlightedUserPos]);
                    }
                    else {
                        this._currentHighlightedUserPos = 0;
                    }
                }
                else if (isCmdOrCtrlKey && keyName === 'ArrowRight') {
                    const person = this._highlightedUsers.pop();
                    if (person) {
                        const personParent = person.parentElement;
                        if (personParent) {
                            this.clearHighlighted(personParent);
                            this._currentHighlightedUserPos++;
                        }
                    }
                }
                else if (isCmdOrCtrlKey && keyName === 'a') {
                    this._highlightedUsers = [];
                    selectedPeople.forEach(person => this._highlightedUsers.push(person));
                }
                if (this._highlightedUsers) {
                    this.highlightSelectedPeople(this._highlightedUsers);
                }
                return;
            }
            this.clearHighlighted();
            if (!this.flyout.isOpen) {
                return;
            }
            if (keyName === 'ArrowUp' || keyName === 'ArrowDown') {
                this.handleArrowSelection(event);
                event.preventDefault();
            }
            if (keyName === 'Enter') {
                if (!event.shiftKey && this._foundPeople) {
                    event.preventDefault();
                    event.stopPropagation();
                    const foundPerson = this._foundPeople[this._arrowSelectionCount];
                    if (foundPerson) {
                        this.addPerson(foundPerson);
                        this.hideFlyout();
                        this.input.value = '';
                        const inputControl = this.input.shadowRoot.querySelector('input');
                        if (this.hasMaxSelections && inputControl) {
                            inputControl.setAttribute('disabled', 'true');
                        }
                    }
                }
                else if (this.allowAnyEmail) {
                    this.handleAnyEmail();
                }
                else {
                    this.showFlyout();
                }
            }
            if (keyName === 'Escape') {
                event.stopPropagation();
            }
            if (keyName === 'Tab') {
                this.hideFlyout();
            }
            if ([';', ','].includes(keyName)) {
                if (this.allowAnyEmail) {
                    event.preventDefault();
                    event.stopPropagation();
                    this.userInput = this.input.value;
                    this.handleAnyEmail();
                }
            }
        };
        /**
         * Handles the cut event when it is fired
         */
        this.handleCut = () => {
            this.writeHighlightedText().then(() => {
                this.removeHighlightedOnCut();
            }, () => {
                // intentionally left blank
            });
        };
        /**
         * Handles the copy event when it is fired
         */
        this.handleCopy = () => {
            void this.writeHighlightedText();
        };
        /**
         * Parses the copied people text and adds them when you paste
         */
        this.handlePaste = () => {
            navigator.clipboard.readText().then(copiedText => {
                if (copiedText) {
                    try {
                        const people = JSON.parse(copiedText);
                        if (people && people.length > 0) {
                            for (const person of people) {
                                this.addPerson(person);
                            }
                        }
                    }
                    catch (error) {
                        if (error instanceof SyntaxError) {
                            const delimiters = [',', ';'];
                            let listOfUsers;
                            try {
                                for (const delimiter of delimiters) {
                                    listOfUsers = copiedText.split(delimiter);
                                    if (listOfUsers.length > 1) {
                                        this.hideFlyout();
                                        void this.selectUsersById(listOfUsers);
                                        break;
                                    }
                                }
                                // eslint-disable-next-line no-empty
                            }
                            catch (_) { }
                        }
                    }
                }
            }, 
            // eslint-disable-next-line @typescript-eslint/no-unused-vars
            error => {
                // 'navigator.clipboard.readText is not a function' error is thrown in Mozilla
                // more information here https://developer.mozilla.org/en-US/docs/Web/API/Clipboard/readText#browser_compatibility
                // Firefox only supports reading the clipboard in browser extensions,
                // using the "clipboardRead" extension permission.
            });
        };
        this.clearState();
        this._showLoading = true;
        this.showMax = 6;
        this.disableImages = false;
        this.disabled = false;
        this.allowAnyEmail = false;
        this.addEventListener('copy', this.handleCopy);
        this.addEventListener('cut', this.handleCut);
        this.addEventListener('paste', this.handlePaste);
    }
    get hasMaxSelections() {
        return this.selectionMode === 'single' && this.selectedPeople.length >= 1;
    }
    /**
     * Focuses the input element when focus is called
     *
     * @param {FocusOptions} [options]
     * @memberof MgtPeoplePicker
     */
    focus(options) {
        if (!this.input) {
            return;
        }
        this.input.focus(options);
        this.input.select();
    }
    /**
     * Queries the microsoft graph for a user based on the user id and adds them to the selectedPeople array
     *
     * @param {readonly string []} an array of user ids to add to selectedPeople
     * @returns {Promise<void>}
     * @memberof MgtPeoplePicker
     */
    selectUsersById(userIds) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            const graph = Providers.globalProvider.graph;
            if (provider && provider.state === ProviderState.SignedIn) {
                // eslint-disable-next-line guard-for-in, @typescript-eslint/no-for-in-array
                for (const id in userIds) {
                    const userId = userIds[id];
                    try {
                        const personDetails = yield getUser(graph, userId, defaultPersonProperties);
                        this.addPerson(personDetails);
                    }
                    catch (e) {
                        // This caters for allow-any-email property if it's enabled on the component
                        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access, @typescript-eslint/no-unsafe-call
                        if (isGraphError(e) && ((_a = e.message) === null || _a === void 0 ? void 0 : _a.includes('does not exist')) && this.allowAnyEmail) {
                            if (isValidEmail(userId)) {
                                const anyMailUser = {
                                    mail: userId,
                                    displayName: userId
                                };
                                this.addPerson(anyMailUser);
                            }
                        }
                    }
                }
            }
        });
    }
    /**
     * Queries the microsoft graph for a group of users from a group id, and adds them to the selectedPeople
     *
     * @param {readonly string []} an array of group ids to add to selectedPeople
     * @returns {Promise<void>}
     * @memberof MgtPeoplePicker
     */
    selectGroupsById(groupIds) {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            const graph = Providers.globalProvider.graph;
            if (provider && provider.state === ProviderState.SignedIn) {
                // eslint-disable-next-line guard-for-in, @typescript-eslint/no-for-in-array
                for (const id in groupIds) {
                    try {
                        const groupDetails = yield getGroup(graph, groupIds[id]);
                        this.addPerson(groupDetails);
                    }
                    catch (e) {
                        // no-op
                    }
                }
            }
        });
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return a lit-html TemplateResult.
     * Setting properties inside this method will not trigger the element to update.
     *
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    render() {
        const defaultTemplate = this.renderTemplate('default', { people: this._foundPeople });
        if (defaultTemplate) {
            return defaultTemplate;
        }
        const selectedPeopleTemplate = this.renderSelectedPeople(this.selectedPeople);
        const inputTemplate = this.renderInput(selectedPeopleTemplate);
        const flyoutTemplate = this.renderFlyout(inputTemplate);
        return html `
      <div>
        ${flyoutTemplate}
      </div>
    `;
    }
    /**
     * Clears state of the component
     *
     * @protected
     * @memberof MgtPeoplePicker
     */
    clearState() {
        this.selectedPeople = [];
        this.userInput = '';
        this._highlightedUsers = [];
        this._currentHighlightedUserPos = 0;
    }
    /**
     * Request to reload the state.
     * Use reload instead of load to ensure loading events are fired.
     *
     * @protected
     * @memberof MgtBaseComponent
     */
    requestStateUpdate(force) {
        if (force) {
            this._groupPeople = null;
            this._foundPeople = null;
            this.selectedPeople = [];
            this.defaultPeople = null;
        }
        return super.requestStateUpdate(force);
    }
    /**
     * Render the input text box.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderInput(selectedPeopleTemplate) {
        var _a, _b, _c;
        const placeholder = this.disabled ? '' : this.placeholder || this.strings.inputPlaceholderText;
        const maxSelectionsAriaLabel = this.hasMaxSelections ? this.strings.maxSelectionsAriaLabel : '';
        const searchIcon = html `<span class="search-icon">${getSvg(SvgIcon.Search)}</span>`;
        const startSlot = ((_a = this.selectedPeople) === null || _a === void 0 ? void 0 : _a.length) > 0 ? selectedPeopleTemplate : searchIcon;
        return html `
      <fluent-text-field
        autocomplete="off"
        appearance="outline"
        slot="anchor"
        id="people-picker-input"
        role="combobox"
        placeholder=${this.hasMaxSelections ? this.strings.maxSelectionsPlaceHolder : placeholder}
        aria-label=${this.ariaLabel || maxSelectionsAriaLabel || placeholder || this.strings.selectContact}
        aria-expanded=${(_c = (_b = this.flyout) === null || _b === void 0 ? void 0 : _b.isOpen) !== null && _c !== void 0 ? _c : false}
        @click="${this.hasMaxSelections ? undefined : this.handleInputClick}"
        @focus="${this.hasMaxSelections ? undefined : this.gainedFocus}"
        @keydown="${this.hasMaxSelections ? undefined : this.onUserKeyDown}"
        @input="${this.hasMaxSelections ? undefined : this.onUserInput}"
        @blur="${this.lostFocus}"
        ?disabled=${this.disabled}
      >
        <span slot="start">${startSlot}</span>
      </fluent-text-field>
    `;
    }
    /**
     * Render the selected people tokens.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderSelectedPeople(selectedPeople) {
        if (!(selectedPeople === null || selectedPeople === void 0 ? void 0 : selectedPeople.length)) {
            return html ``;
        }
        return html `
       <ul
        id="selected-list"
        aria-label="${this.strings.selected}"
        class="selected-list">
          ${repeat(selectedPeople, person => person === null || person === void 0 ? void 0 : person.id, person => {
            var _a;
            return html `
            <li class="selected-list-item">
              ${this.renderTemplate('selected-person', { person }, `selected-${(person === null || person === void 0 ? void 0 : person.id) ? person.id : person.displayName}`) || this.renderSelectedPerson(person)}

              <div
                role="button"
                tabindex="0"
                class="selected-list-item-close-icon"
                aria-label="${this.strings.removeSelectedUser}${(_a = person === null || person === void 0 ? void 0 : person.displayName) !== null && _a !== void 0 ? _a : ''}"
                @click="${(e) => this.removePerson(person, e)}"
                @keydown="${(e) => this.handleRemovePersonKeyDown(person, e)}">
                  ${getSvg(SvgIcon.Close)}
              </div>
          </li>`;
        })}
      </ul>`;
    }
    /**
     * Render the flyout chrome.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderFlyout(anchor) {
        return mgtHtml `
       <mgt-flyout light-dismiss class="flyout">
         ${anchor}
         <fluent-card
          tabindex="0"
          slot="flyout"
          class="flyout-root"
          @wheel=${(e) => this.handleSectionScroll(e)}
          @keydown=${(e) => this.onUserKeyDown(e)}
          class="custom">
           ${this.renderFlyoutContent()}
         </fluent-card>
       </mgt-flyout>
     `;
    }
    /**
     * Render the appropriate state in the results flyout.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderFlyoutContent() {
        if (this.isLoadingState || this._showLoading) {
            return this.renderLoading();
        }
        const people = this._foundPeople;
        if (!people || people.length === 0 || this.showMax === 0) {
            return this.renderNoData();
        }
        else {
            return this.renderSearchResults(people);
        }
    }
    /**
     * Render the loading state.
     *
     * @protected
     * @returns
     * @memberof MgtPeoplePicker
     */
    renderLoading() {
        return (this.renderTemplate('loading', null) ||
            mgtHtml `
         <div class="message-parent">
           <mgt-spinner></mgt-spinner>
           <div aria-label="${this.strings.loadingMessage}" class="loading-text">
             ${this.strings.loadingMessage}
           </div>
         </div>
       `);
    }
    /**
     * Render the state when no results are found for the search query.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderNoData() {
        if (!this._isFocused) {
            return;
        }
        return (this.renderTemplate('error', null) ||
            this.renderTemplate('no-data', null) ||
            html `
         <div class="message-parent">
           <div aria-label=${this.strings.noResultsFound} class="search-error-text">
             ${this.strings.noResultsFound}
           </div>
         </div>
       `);
    }
    /**
     * Render the list of search results.
     *
     * @protected
     * @param {IDynamicPerson[]} people
     * @returns
     * @memberof MgtPeoplePicker
     */
    renderSearchResults(people) {
        const filteredPeople = people.filter(person => person.id);
        return html `
      <ul
        id="suggestions-list"
        class="searched-people-list"
        role="listbox"
        aria-live="polite"
        title=${this.strings.suggestionsTitle}
      >
         ${repeat(filteredPeople, person => person.id, person => html `
            <li
              id="${person.id}"
              class="searched-people-list-result"
              role="option"
              @click="${() => this.handleSuggestionClick(person)}">
                ${this.renderPersonResult(person)}
            </li>
          `)}
       </ul>
     `;
    }
    /**
     * Render an individual person search result.
     *
     * @protected
     * @param {IDynamicPerson} person
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderPersonResult(person) {
        return (this.renderTemplate('person', { person }, person.id) ||
            mgtHtml `
         <mgt-person
          class="person"
          show-presence
          view="twoLines"
          line2-property="jobTitle,mail"
          .personDetails=${person}
          .fetchImage=${!this.disableImages}>
          .personCardInteraction=${PersonCardInteraction.none}
        </mgt-person>`);
    }
    /**
     * Render an individual selected person token.
     *
     * @protected
     * @param {IDynamicPerson} person
     * @returns {TemplateResult}
     * @memberof MgtPeoplePicker
     */
    renderSelectedPerson(person) {
        return mgtHtml `
       <mgt-person
         tabindex="-1"
         class="selected-list-item-person"
         .personDetails=${person}
         .fetchImage=${!this.disableImages}
         .view=${ViewType.oneline}
         .personCardInteraction=${PersonCardInteraction.none}>
        </mgt-person>
     `;
    }
    /**
     * Async query to Graph for members of group if determined by developer.
     * set's `this.groupPeople` to those members.
     */
    loadState() {
        var _a, _b, _c, _d;
        return __awaiter(this, void 0, void 0, function* () {
            let people = this.people;
            const input = this.userInput.toLowerCase();
            const provider = Providers.globalProvider;
            if (people) {
                if (input) {
                    const displayNameMatch = people.filter(person => person === null || person === void 0 ? void 0 : person.displayName.toLowerCase().includes(input));
                    people = displayNameMatch;
                }
                this._showLoading = false;
            }
            else if (!people && provider && provider.state === ProviderState.SignedIn) {
                const graph = provider.graph.forComponent(this);
                if (!input.length) {
                    if (this.defaultPeople) {
                        people = this.defaultPeople;
                    }
                    else {
                        if (this.groupId || this.groupIds) {
                            if (this._groupPeople === null) {
                                if (this.groupId) {
                                    try {
                                        if (this.type === PersonType.group) {
                                            this._groupPeople = yield findGroupMembers(graph, null, this.groupId, this.showMax, this.type, this.transitiveSearch);
                                        }
                                        else {
                                            this._groupPeople = yield findGroupMembers(graph, null, this.groupId, this.showMax, this.type, this.transitiveSearch, this.userFilters, this.peopleFilters);
                                        }
                                    }
                                    catch (_) {
                                        this._groupPeople = [];
                                    }
                                }
                                else if (this.groupIds) {
                                    if (this.type === PersonType.group) {
                                        try {
                                            this._groupPeople = yield getGroupsForGroupIds(graph, this.groupIds, this.groupFilters);
                                        }
                                        catch (_) {
                                            this._groupPeople = [];
                                        }
                                    }
                                    else {
                                        try {
                                            const peopleInGroups = yield findUsersFromGroupIds(graph, '', this.groupIds, this.showMax, this.type, this.transitiveSearch, this.userFilters);
                                            this._groupPeople = peopleInGroups;
                                        }
                                        catch (_) {
                                            this._groupPeople = [];
                                        }
                                    }
                                }
                            }
                            people = this._groupPeople || [];
                        }
                        else if (this.type === PersonType.person || this.type === PersonType.any) {
                            if (this.userIds) {
                                people = yield getUsersForUserIds(graph, this.userIds, '', this.userFilters);
                            }
                            else {
                                const isUserOrContactType = this.userType === UserType.user || this.userType === UserType.contact;
                                if (this._userFilters && isUserOrContactType) {
                                    people = yield getUsers(graph, this._userFilters, this.showMax);
                                }
                                else {
                                    people = yield getPeople(graph, this.userType, this._peopleFilters, this.showMax);
                                }
                            }
                        }
                        else if (this.type === PersonType.group) {
                            if (this.groupIds) {
                                try {
                                    people = yield this.getGroupsForGroupIds(graph, people);
                                }
                                catch (_) {
                                    // nop
                                }
                            }
                            else {
                                let groups = (yield findGroups(graph, '', this.showMax, this.groupType, this._groupFilters)) || [];
                                // eslint-disable-next-line @typescript-eslint/dot-notation
                                if (groups.length > 0 && groups[0]['value']) {
                                    // eslint-disable-next-line @typescript-eslint/dot-notation, @typescript-eslint/no-unsafe-assignment
                                    groups = groups[0]['value'];
                                }
                                people = groups;
                            }
                        }
                        this.defaultPeople = people;
                    }
                    if (this._isFocused) {
                        this._showLoading = false;
                    }
                }
                if ((((_a = this.defaultSelectedUserIds) === null || _a === void 0 ? void 0 : _a.length) > 0 || ((_b = this.defaultSelectedGroupIds) === null || _b === void 0 ? void 0 : _b.length) > 0) &&
                    !this.selectedPeople.length &&
                    !this.defaultSelectedUsers.length &&
                    !this.defaultSelectedGroups.length) {
                    this.defaultSelectedUsers = yield getUsersForUserIds(graph, this.defaultSelectedUserIds, '', this.userFilters);
                    this.defaultSelectedGroups = yield getGroupsForGroupIds(graph, this.defaultSelectedGroupIds, this.peopleFilters);
                    this.defaultSelectedGroups = this.defaultSelectedGroups.filter(group => {
                        return group !== null;
                    });
                    this.defaultSelectedUsers = this.defaultSelectedUsers.filter(user => {
                        return user !== null;
                    });
                    this.selectedPeople = [...this.defaultSelectedUsers, ...this.defaultSelectedGroups];
                    this.requestUpdate();
                    this.fireCustomEvent('selectionChanged', this.selectedPeople);
                }
                if (input) {
                    people = [];
                    if (this.groupId) {
                        people =
                            (yield findGroupMembers(graph, input, this.groupId, this.showMax, this.type, this.transitiveSearch, this.userFilters, this.peopleFilters)) || [];
                    }
                    else {
                        if (this.type === PersonType.person || this.type === PersonType.any) {
                            try {
                                // Default UserType === any
                                if (this.userType === UserType.contact || this.userType === UserType.user) {
                                    // we might have a user-filters property set, search for users with it.
                                    if ((_c = this.userIds) === null || _c === void 0 ? void 0 : _c.length) {
                                        // has the user-ids proerty set
                                        people = yield getUsersForUserIds(graph, this.userIds, input, this._userFilters);
                                    }
                                    else {
                                        people = yield findUsers(graph, input, this.showMax, this._userFilters);
                                    }
                                }
                                else {
                                    if (!this.groupIds) {
                                        if ((_d = this.userIds) === null || _d === void 0 ? void 0 : _d.length) {
                                            // has the user-ids proerty set
                                            people = yield getUsersForUserIds(graph, this.userIds, input, this._userFilters);
                                        }
                                        else {
                                            people = (yield findPeople(graph, input, this.showMax, this.userType, this._peopleFilters)) || [];
                                        }
                                    }
                                    else {
                                        // Does not work when the PersonType = person.
                                        try {
                                            people = yield findUsersFromGroupIds(graph, input, this.groupIds, this.showMax, this.type, this.transitiveSearch, this.userFilters);
                                        }
                                        catch (_) {
                                            // nop
                                        }
                                    }
                                }
                            }
                            catch (e) {
                                // nop
                            }
                            // Don't follow this path if a people-filters attribute is set on the component as the
                            // default type === PersonType.person
                            if (people &&
                                people.length < this.showMax &&
                                this.userType !== UserType.contact &&
                                this.type !== PersonType.person) {
                                try {
                                    const users = (yield findUsers(graph, input, this.showMax, this._userFilters)) || [];
                                    // make sure only unique people
                                    const peopleIds = new Set(people.map(p => p.id));
                                    for (const user of users) {
                                        if (!peopleIds.has(user.id)) {
                                            people.push(user);
                                        }
                                    }
                                }
                                catch (e) {
                                    // no-op
                                }
                            }
                        }
                        if ((this.type === PersonType.group || this.type === PersonType.any) && people.length < this.showMax) {
                            if (this.groupIds) {
                                try {
                                    people = yield findGroupsFromGroupIds(graph, input, this.groupIds, this.showMax, this.groupType, this.userFilters);
                                }
                                catch (_) {
                                    // no-op
                                }
                            }
                            else {
                                let groups = [];
                                try {
                                    groups = (yield findGroups(graph, input, this.showMax, this.groupType, this._groupFilters)) || [];
                                    people = people.concat(groups);
                                }
                                catch (e) {
                                    // nop
                                }
                            }
                        }
                    }
                }
            }
            // people = this.getUniquePeople(people);
            this._foundPeople = this.filterPeople(people);
        });
    }
    /**
     * Gets the Groups in a list of group IDs.
     *
     * @param graph the graph object
     * @param people already found groups
     * @returns groups found
     */
    getGroupsForGroupIds(graph, people) {
        return __awaiter(this, void 0, void 0, function* () {
            const groups = yield getGroupsForGroupIds(graph, this.groupIds, this.groupFilters);
            for (const group of groups) {
                people = people.concat(group);
            }
            people = people.filter(person => person);
            return people;
        });
    }
    /**
     * Hide the results flyout.
     *
     * @protected
     * @memberof MgtPeoplePicker
     */
    hideFlyout() {
        const flyout = this.flyout;
        if (flyout) {
            flyout.close();
        }
        if (this.input) {
            this.input.setAttribute('aria-activedescendant', '');
        }
        this._arrowSelectionCount = -1;
    }
    /**
     * Show the results flyout.
     *
     * @protected
     * @memberof MgtPeoplePicker
     */
    showFlyout() {
        const flyout = this.flyout;
        if (flyout) {
            flyout.open();
        }
        this._arrowSelectionCount = -1;
    }
    /**
     * Removes person from selected people
     *
     * @param person - person and details pertaining to user selected
     */
    removePerson(person, e) {
        e.stopPropagation();
        const filteredPersonArr = this.selectedPeople.filter(p => {
            if (!person.id && p.displayName) {
                return p.displayName !== person.displayName;
            }
            return p.id !== person.id;
        });
        const inputControl = this.input.shadowRoot.querySelector('input');
        if (this.hasMaxSelections && inputControl) {
            inputControl.removeAttribute('disabled');
        }
        this.selectedPeople = filteredPersonArr;
        void this.loadState();
        this.fireCustomEvent('selectionChanged', this.selectedPeople);
        inputControl === null || inputControl === void 0 ? void 0 : inputControl.focus();
    }
    /**
     * Checks if key pressed is an `Enter` key before removing person
     *
     * @param person
     * @param e
     */
    handleRemovePersonKeyDown(person, e) {
        if (e.key === 'Enter') {
            this.removePerson(person, e);
        }
    }
    /**
     * Tracks when user selects person from picker
     *
     * @param person - contains details pertaining to selected user
     * @param event - tracks user event
     */
    addPerson(person) {
        if (person) {
            setTimeout(() => {
                this.clearInput();
            }, 50);
            const duplicatePeople = this.selectedPeople.filter(p => {
                if (!person.id && p.displayName) {
                    return p.displayName === person.displayName;
                }
                return p.id === person.id;
            });
            if (duplicatePeople.length === 0) {
                this.selectedPeople = [...this.selectedPeople, person];
                this.fireCustomEvent('selectionChanged', this.selectedPeople);
                void this.loadState();
                this._foundPeople = [];
                this._arrowSelectionCount = -1;
            }
        }
    }
    clearInput() {
        this.clearHighlighted();
        if (this.selectionMode !== 'single') {
            this.input.value = '';
        }
        this.userInput = '';
    }
    handleAnyEmail() {
        this._showLoading = false;
        this._arrowSelectionCount = -1;
        if (isValidEmail(this.userInput)) {
            const anyMailUser = {
                mail: this.userInput,
                displayName: this.userInput
            };
            this.addPerson(anyMailUser);
        }
        this.hideFlyout();
        if (this.input) {
            this.input.focus();
            this._isFocused = true;
        }
    }
    // handle suggestion list item click
    handleSuggestionClick(person) {
        this.addPerson(person);
        const inputControl = this.input.shadowRoot.querySelector('input');
        if (this.hasMaxSelections && inputControl) {
            inputControl.setAttribute('disabled', 'true');
            this.input.value = inputControl.value = '';
        }
        this.hideFlyout();
    }
    /**
     * Tracks event on user input in search
     *
     * @param input - input text
     */
    handleUserSearch() {
        if (!this._debouncedSearch) {
            this._debouncedSearch = debounce(() => __awaiter(this, void 0, void 0, function* () {
                const loadingTimeout = setTimeout(() => {
                    this._showLoading = true;
                }, 50);
                yield this.loadState();
                clearTimeout(loadingTimeout);
                this._showLoading = false;
                this._arrowSelectionCount = -1;
                this.showFlyout();
            }), 400);
        }
        this._debouncedSearch();
    }
    /**
     * Gets the text of the highlighed people and writes it to the clipboard
     */
    writeHighlightedText() {
        return __awaiter(this, void 0, void 0, function* () {
            const copyText = [];
            for (const element of this._highlightedUsers) {
                // eslint-disable-next-line @typescript-eslint/dot-notation
                const { id, displayName, mail, userPrincipalName, scoredEmailAddresses } = element['_personDetails'];
                let emailAddress;
                if (scoredEmailAddresses && scoredEmailAddresses.length > 0) {
                    emailAddress = scoredEmailAddresses.pop().address;
                }
                else {
                    emailAddress = userPrincipalName || mail;
                }
                copyText.push({ id, displayName, email: emailAddress });
            }
            let copiedTextStr = '';
            if (copyText.length > 0) {
                copiedTextStr = JSON.stringify(copyText);
            }
            yield navigator.clipboard.writeText(copiedTextStr);
        });
    }
    /**
     * Removes only the highlighted elements from the peoplePicker during cut operations.
     */
    removeHighlightedOnCut() {
        this.selectedPeople = this.selectedPeople.splice(0, this.selectedPeople.length - this._highlightedUsers.length);
        this._highlightedUsers = [];
        this._currentHighlightedUserPos = 0;
        void this.loadState();
        this.hideFlyout();
        this.fireCustomEvent('selectionChanged', this.selectedPeople);
    }
    /**
     * Changes the color class to show which people are selected for copy/cut-paste
     *
     * @param people list of selected people classes
     */
    highlightSelectedPeople(people) {
        for (const person of people) {
            const parentElement = person === null || person === void 0 ? void 0 : person.parentElement;
            parentElement.classList.add('highlighted');
        }
    }
    /**
     * Defaults the people class back to the normal view
     */
    clearHighlighted(node) {
        if (node) {
            node.classList.remove('highlighted');
        }
        else {
            for (const person of this._highlightedUsers) {
                const parentElement = person.parentElement;
                if (parentElement) {
                    parentElement.classList.remove('highlighted');
                }
            }
            this._highlightedUsers = [];
            this._currentHighlightedUserPos = 0;
        }
    }
    /**
     * Tracks user key selection for arrow key selection of people
     *
     * @param event - tracks user key selection
     */
    handleArrowSelection(event) {
        var _a, _b;
        const peopleList = this.renderRoot.querySelector('.searched-people-list');
        if ((_a = peopleList === null || peopleList === void 0 ? void 0 : peopleList.children) === null || _a === void 0 ? void 0 : _a.length) {
            if (event) {
                // update arrow count
                if (event.key === 'ArrowUp') {
                    if (this._arrowSelectionCount === -1) {
                        this._arrowSelectionCount = 0;
                    }
                    else {
                        this._arrowSelectionCount =
                            (this._arrowSelectionCount - 1 + peopleList.children.length) % peopleList.children.length;
                    }
                }
                if (event.key === 'ArrowDown') {
                    if (this._arrowSelectionCount === -1) {
                        this._arrowSelectionCount = 0;
                    }
                    else {
                        this._arrowSelectionCount =
                            (this._arrowSelectionCount + 1 + peopleList.children.length) % peopleList.children.length;
                    }
                }
            }
            for (const person of (_b = peopleList === null || peopleList === void 0 ? void 0 : peopleList.children) !== null && _b !== void 0 ? _b : []) {
                const p = person;
                p.setAttribute('aria-selected', 'false');
                p.blur();
                p.removeAttribute('tabindex');
            }
            // set selected background
            // set aria-selected to true
            const focusedItem = peopleList.children[this._arrowSelectionCount];
            if (focusedItem) {
                focusedItem.setAttribute('tabindex', '0');
                focusedItem.focus();
                focusedItem.scrollIntoView({ behavior: 'smooth', block: 'nearest', inline: 'nearest' });
                focusedItem.setAttribute('aria-selected', 'true');
                this.input.setAttribute('aria-activedescendant', focusedItem === null || focusedItem === void 0 ? void 0 : focusedItem.id);
            }
        }
    }
    /**
     * Filters people searched from already selected people
     *
     * @param people - array of people returned from query to Graph
     */
    filterPeople(people) {
        // check if people need to be updated
        // ensuring people list is displayed
        // find ids from selected people
        const uniquePeople = [];
        if (people && people.length > 0) {
            people = people.filter(person => person);
            const idFilter = this.selectedPeople.map(el => {
                return el.id ? el.id : el.displayName;
            });
            // filter id's
            const filtered = people.filter((person) => {
                if (person === null || person === void 0 ? void 0 : person.id) {
                    return idFilter.indexOf(person.id) === -1;
                }
                else {
                    return idFilter.indexOf(person === null || person === void 0 ? void 0 : person.displayName) === -1;
                }
            });
            // remove duplicates
            const dupsSet = new Set();
            for (const d of filtered) {
                const person = JSON.stringify(d);
                dupsSet.add(person);
            }
            dupsSet.forEach((person) => {
                const p = JSON.parse(person);
                uniquePeople.push(p);
            });
        }
        return uniquePeople;
    }
    // stop propagating wheel event to flyout so mouse scrolling works
    handleSectionScroll(e) {
        const target = this.renderRoot.querySelector('.flyout-root');
        if (target) {
            if (!(e.deltaY < 0 && target.scrollTop === 0) &&
                !(e.deltaY > 0 && target.clientHeight + target.scrollTop >= target.scrollHeight - 1)) {
                e.stopPropagation();
            }
        }
    }
};
__decorate([
    property({ attribute: 'group-id', converter: value => value.trim() }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "groupId", null);
__decorate([
    property({
        attribute: 'group-ids',
        converter: value => {
            return value.split(',').map(v => v.trim());
        }
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "groupIds", null);
__decorate([
    property({
        attribute: 'type',
        converter: value => {
            value = value.toLowerCase();
            if (!value || value.length === 0) {
                return PersonType.any;
            }
            if (typeof PersonType[value] === 'undefined') {
                return PersonType.any;
            }
            else {
                return PersonType[value];
            }
        }
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "type", null);
__decorate([
    property({
        attribute: 'group-type',
        converter: value => {
            if (!value || value.length === 0) {
                return GroupType.any;
            }
            const values = value.split(',');
            const groupTypes = [];
            for (let v of values) {
                v = v.trim();
                if (typeof GroupType[v] !== 'undefined') {
                    groupTypes.push(GroupType[v]);
                }
            }
            if (groupTypes.length === 0) {
                return GroupType.any;
            }
            // eslint-disable-next-line no-bitwise
            const gt = groupTypes.reduce((a, c) => a | c);
            return gt;
        }
    }),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "groupType", null);
__decorate([
    property({
        attribute: 'user-type',
        converter: value => {
            value = value.toLowerCase();
            return !value || typeof UserType[value] === 'undefined' ? UserType.any : UserType[value];
        }
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "userType", null);
__decorate([
    property({
        attribute: 'transitive-search',
        type: Boolean
    }),
    __metadata("design:type", Boolean),
    __metadata("design:paramtypes", [Boolean])
], MgtPeoplePicker.prototype, "transitiveSearch", null);
__decorate([
    property({
        attribute: 'people',
        type: Object
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], MgtPeoplePicker.prototype, "people", null);
__decorate([
    property({
        attribute: 'show-max',
        type: Number
    }),
    __metadata("design:type", Number),
    __metadata("design:paramtypes", [Number])
], MgtPeoplePicker.prototype, "showMax", null);
__decorate([
    property({
        attribute: 'disable-images',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPeoplePicker.prototype, "disableImages", void 0);
__decorate([
    property({
        attribute: 'selected-people',
        type: Array
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], MgtPeoplePicker.prototype, "selectedPeople", null);
__decorate([
    property({
        attribute: 'default-selected-user-ids',
        converter: value => {
            return value.split(',').map(v => v.trim());
        },
        type: String
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "defaultSelectedUserIds", null);
__decorate([
    property({
        attribute: 'default-selected-group-ids',
        converter: value => {
            return value.split(',').map(v => v.trim());
        },
        type: String
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Object])
], MgtPeoplePicker.prototype, "defaultSelectedGroupIds", null);
__decorate([
    property({
        attribute: 'placeholder',
        type: String
    }),
    __metadata("design:type", String)
], MgtPeoplePicker.prototype, "placeholder", void 0);
__decorate([
    property({
        attribute: 'disabled',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPeoplePicker.prototype, "disabled", void 0);
__decorate([
    property({
        attribute: 'allow-any-email',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPeoplePicker.prototype, "allowAnyEmail", void 0);
__decorate([
    property({
        attribute: 'selection-mode',
        type: String
    }),
    __metadata("design:type", String)
], MgtPeoplePicker.prototype, "selectionMode", void 0);
__decorate([
    property({
        attribute: 'user-ids',
        converter: value => {
            return value.split(',').map(v => v.trim());
        },
        type: String
    }),
    __metadata("design:type", Array),
    __metadata("design:paramtypes", [Array])
], MgtPeoplePicker.prototype, "userIds", null);
__decorate([
    property({ attribute: 'user-filters' }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPeoplePicker.prototype, "userFilters", null);
__decorate([
    property({ attribute: 'people-filters' }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPeoplePicker.prototype, "peopleFilters", null);
__decorate([
    property({ attribute: 'group-filters' }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPeoplePicker.prototype, "groupFilters", null);
__decorate([
    property({
        attribute: 'aria-label',
        type: String
    }),
    __metadata("design:type", String)
], MgtPeoplePicker.prototype, "ariaLabel", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPeoplePicker.prototype, "_showLoading", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPeoplePicker.prototype, "_arrowSelectionCount", void 0);
__decorate([
    state(),
    __metadata("design:type", Array)
], MgtPeoplePicker.prototype, "_highlightedUsers", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPeoplePicker.prototype, "_isFocused", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPeoplePicker.prototype, "_setAnyEmail", void 0);
__decorate([
    state(),
    __metadata("design:type", Array)
], MgtPeoplePicker.prototype, "_foundPeople", void 0);
MgtPeoplePicker = __decorate([
    customElement('people-picker'),
    __metadata("design:paramtypes", [])
], MgtPeoplePicker);
export { MgtPeoplePicker };
//# sourceMappingURL=mgt-people-picker.js.map