/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var MgtPerson_1;
import { MgtTemplatedComponent, ProviderState, Providers, customElement, customElementHelper, mgtHtml } from '@microsoft/mgt-element';
import { html, nothing } from 'lit';
import { property, state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { findPeople, getEmailFromGraphEntity } from '../../graph/graph.people';
import { getGroupImage, getPersonImage } from '../../graph/graph.photos';
import { getUserPresence } from '../../graph/graph.presence';
import { findUsers, getMe, getUser } from '../../graph/graph.user';
import { getUserWithPhoto } from '../../graph/graph.userWithPhoto';
import { ViewType } from '../../graph/types';
import '../../styles/style-helper';
import { SvgIcon, getSvg } from '../../utils/SvgHelper';
import '../sub-components/mgt-flyout/mgt-flyout';
import { PersonCardInteraction } from './../PersonCardInteraction';
import { styles } from './mgt-person-css';
import { PersonViewType, avatarType } from './mgt-person-types';
import { strings } from './strings';
import { isUser, isContact } from '../../graph/entityType';
import { ifDefined } from 'lit/directives/if-defined.js';
export { PersonCardInteraction } from '../PersonCardInteraction';
/**
 * Person properties part of original set provided by graph by default
 */
export const defaultPersonProperties = [
    'businessPhones',
    'displayName',
    'givenName',
    'jobTitle',
    'department',
    'mail',
    'mobilePhone',
    'officeLocation',
    'preferredLanguage',
    'surname',
    'userPrincipalName',
    'id',
    'userType'
];
/**
 * The person component is used to display a person or contact by using their photo, name, and/or email address.
 *
 * @export
 * @class MgtPerson
 * @extends {MgtTemplatedComponent}
 *
 * @fires {CustomEvent<IDynamicPerson>} line1clicked - Fired when line1 is clicked
 * @fires {CustomEvent<IDynamicPerson>} line2clicked - Fired when line2 is clicked
 * @fires {CustomEvent<IDynamicPerson>} line3clicked - Fired when line3 is clicked
 * @fires {CustomEvent<IDynamicPerson>} line4clicked - Fired when line4 is clicked
 *
 * @cssprop --person-background-color - {Color} the color of the person component background.
 * @cssprop --person-background-border-radius - {Length} the border radius of the person component. Default is 4px.
 *
 * @cssprop --person-avatar-size - {Length} the width and height of the avatar. Default is 24px.
 * @cssprop --person-avatar-border - {String} the border around an avatar. Default is none.
 * @cssprop --person-avatar-border-radius - {String} the radius around the border of an avatar. Default is 50%.
 *
 * @cssprop --person-initials-text-color - {Color} the color of initials in an avatar.
 * @cssprop --person-initials-background-color - {Color} the color of the background in an avatar with initials.
 *
 * @cssprop --person-details-spacing - {Length} the space between the avatar and the person details. Default is 12px.
 *
 * @cssprop --person-line1-font-size - {String} the font-size of the line 1 text. Default is 14px.
 * @cssprop --person-line1-font-weight - {Length} the font weight of the line 1 text. Default is 600.
 * @cssprop --person-line1-text-color - {Color} the color of the line 1 text.
 * @cssprop --person-line1-text-transform - {String} the tex transform of the line 1 text. Default is inherit.
 * @cssprop --person-line1-text-line-height - {Length} the line height of the line 1 text. Default is 20px.
 *
 * @cssprop --person-line2-font-size - {Length} the font-size of the line 2 text. Default is 12px.
 * @cssprop --person-line2-font-weight - {Length} the font weight of the line 2 text. Default is 400.
 * @cssprop --person-line2-text-color - {Color} the color of the line 2 text.
 * @cssprop --person-line2-text-transform - {String} the tex transform of the line 2 text. Default is inherit.
 * @cssprop --person-line2-text-line-height - {Length} the line height of the line 2 text. Default is 16px.
 *
 * @cssprop --person-line3-font-size - {Length} the font-size of the line 3 text. Default is 12px.
 * @cssprop --person-line3-font-weight - {Length} the font weight of the line 3 text. Default is 400.
 * @cssprop --person-line3-text-color - {Color} the color of the line 3 text.
 * @cssprop --person-line3-text-transform - {String} the tex transform of the line 3 text. Default is inherit.
 * @cssprop --person-line3-text-line-height - {Length} the line height of the line 3 text. Default is 16px.
 *
 * @cssprop --person-line4-font-size - {Length} the font-size of the line 4 text. Default is 12px.
 * @cssprop --person-line4-font-weight - {Length} the font weight of the line 4 text. Default is 400.
 * @cssprop --person-line4-text-color - {Color} the color of the line 4 text.
 * @cssprop --person-line4-text-transform - {String} the tex transform of the line 4 text. Default is inherit.
 * @cssprop --person-line4-text-line-height - {Length} the line height of the line 4 text. Default is 16px.
 *
 * @cssprop --person-details-wrapper-width - {Length} the minimum width of the details section. Default is 168px.
 */
let MgtPerson = MgtPerson_1 = class MgtPerson extends MgtTemplatedComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * Strings to use for localization
     *
     * @readonly
     * @protected
     * @memberof MgtPerson
     */
    get strings() {
        return strings;
    }
    /**
     * allows developer to define name of person for component
     *
     * @type {string}
     */
    get personQuery() {
        return this._personQuery;
    }
    set personQuery(value) {
        if (value === this._personQuery) {
            return;
        }
        this._personQuery = value;
        this.personDetailsInternal = null;
        void this.requestStateUpdate();
    }
    /**
     * Fallback when no user is found
     *
     * @type {IDynamicPerson}
     */
    get fallbackDetails() {
        return this._fallbackDetails;
    }
    set fallbackDetails(value) {
        if (value === this._fallbackDetails) {
            return;
        }
        this._fallbackDetails = value;
        if (this.personDetailsInternal) {
            return;
        }
        void this.requestStateUpdate();
    }
    /**
     * user-id property allows developer to use id value to determine person
     *
     * @type {string}
     */
    get userId() {
        return this._userId;
    }
    set userId(value) {
        if (value === this._userId) {
            return;
        }
        this._userId = value;
        this.personDetailsInternal = null;
        void this.requestStateUpdate();
    }
    /**
     * usage property allows you to specify where the component is being used to add
     * customized personalization for it. Currently only supports "people" as used in
     * the people component.
     *
     * @type {string}
     */
    get usage() {
        return this._usage;
    }
    set usage(value) {
        if (value === this._usage) {
            return;
        }
        this._usage = value;
        void this.requestStateUpdate();
    }
    /**
     * object containing Graph details on person
     * a copy of person-details attribute
     *
     * @type {IDynamicPerson}
     */
    get personDetailsInternal() {
        return this._personDetailsInternal;
    }
    set personDetailsInternal(value) {
        if (this._personDetailsInternal === value) {
            return;
        }
        this._personDetailsInternal = value;
        this._fetchedImage = null;
        this._fetchedPresence = null;
        void this.requestStateUpdate();
        this.requestUpdate('personDetailsInternal');
    }
    /**
     * object containing Graph details on person
     *
     * @type {IDynamicPerson}
     */
    get personDetails() {
        return this._personDetails;
    }
    set personDetails(value) {
        if (this._personDetails === value) {
            return;
        }
        this._personDetails = value;
        this._fetchedImage = null;
        this._fetchedPresence = null;
        void this.requestStateUpdate();
        this.requestUpdate('personDetails');
    }
    /**
     * Set the image of the person
     *
     * @type {string}
     * @memberof MgtPersonCard
     */
    get personImage() {
        return this._personImage || this._fetchedImage;
    }
    set personImage(value) {
        if (value === this._personImage) {
            return;
        }
        this._isInvalidImageSrc = !value;
        const oldValue = this._personImage;
        this._personImage = value;
        this.requestUpdate('personImage', oldValue);
    }
    /**
     * Determines and sets person avatar
     *
     *
     * @type {string}
     * @memberof MgtPerson
     */
    get avatarType() {
        return this._avatarType;
    }
    set avatarType(value) {
        if (value === this._avatarType) {
            return;
        }
        this._avatarType = value;
        void this.requestStateUpdate();
    }
    /**
     * Gets or sets presence of person
     *
     * @type {MicrosoftGraph.Presence}
     * @memberof MgtPerson
     */
    get personPresence() {
        return this._personPresence || this._fetchedPresence;
    }
    set personPresence(value) {
        if (value === this._personPresence) {
            return;
        }
        const oldValue = this._personPresence;
        this._personPresence = value;
        this.requestUpdate('personPresence', oldValue);
    }
    /**
     * Get the scopes required for person
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtPerson
     */
    static get requiredScopes() {
        const scopes = ['user.readbasic.all', 'user.read', 'people.read', 'presence.read.all', 'presence.read'];
        if (MgtPerson_1.config.useContactApis) {
            scopes.push('contacts.read');
        }
        return scopes;
    }
    /**
     * Gets the flyout element
     *
     * @protected
     * @type {MgtFlyout}
     * @memberof MgtPerson
     */
    get flyout() {
        return this.renderRoot.querySelector('.flyout');
    }
    constructor() {
        super();
        this._mouseLeaveTimeout = -1;
        this._mouseEnterTimeout = -1;
        this.handleMouseClick = (e) => {
            const element = e.target;
            // todo: fix for disambiguation
            if (this.personCardInteraction === PersonCardInteraction.click &&
                element.tagName !== `${customElementHelper.prefix}-PERSON-CARD`.toUpperCase()) {
                this.showPersonCard();
            }
        };
        this.handleKeyDown = (e) => {
            // enter activates person-card
            if (e) {
                if (e.key === 'Enter') {
                    this.showPersonCard();
                }
            }
        };
        this.handleMouseEnter = () => {
            clearTimeout(this._mouseEnterTimeout);
            clearTimeout(this._mouseLeaveTimeout);
            if (this.personCardInteraction !== PersonCardInteraction.hover) {
                return;
            }
            this._mouseEnterTimeout = window.setTimeout(this.showPersonCard, 500);
        };
        this.handleMouseLeave = () => {
            clearTimeout(this._mouseEnterTimeout);
            clearTimeout(this._mouseLeaveTimeout);
            this._mouseLeaveTimeout = window.setTimeout(this.hidePersonCard, 500);
        };
        /**
         * hides the person card
         *
         * @memberof MgtPerson
         */
        this.hidePersonCard = () => {
            const flyout = this.flyout;
            if (flyout) {
                flyout.close();
            }
            const personCard = this.querySelector('.mgt-person-card') || this.renderRoot.querySelector('.mgt-person-card');
            if (personCard) {
                personCard.isExpanded = false;
                personCard.clearHistory();
            }
        };
        this.showPersonCard = () => {
            if (!this._personCardShouldRender) {
                this._personCardShouldRender = true;
            }
            const flyout = this.flyout;
            if (flyout) {
                flyout.open();
            }
        };
        // defaults
        this.personCardInteraction = PersonCardInteraction.none;
        this.line1Property = 'displayName';
        this.line2Property = 'jobTitle';
        this.line3Property = 'department';
        this.line4Property = 'email';
        this.view = ViewType.image;
        this.avatarSize = 'auto';
        this.disableImageFetch = false;
        this._isInvalidImageSrc = false;
        this._avatarType = avatarType.photo;
        this.verticalLayout = false;
    }
    /**
     * Invoked on each update to perform rendering tasks. This method must return
     * a lit-html TemplateResult. Setting properties inside this method will *not*
     * trigger the element to update.
     */
    render() {
        // Loading
        if (this.isLoadingState && !this.personDetails && !this.personDetailsInternal && !this.fallbackDetails) {
            return this.renderLoading();
        }
        // Prep data
        const person = this.personDetails || this.personDetailsInternal || this.fallbackDetails;
        const image = this.getImage();
        const presence = this.personPresence || this._fetchedPresence;
        if (!person && !image) {
            return this.renderNoData();
        }
        if (!(person === null || person === void 0 ? void 0 : person.personImage) && image) {
            person.personImage = image;
        }
        // Default template
        let personTemplate = this.renderTemplate('default', { person, personImage: image, personPresence: presence });
        if (!personTemplate) {
            const detailsTemplate = this.renderDetails(person, presence);
            const imageWithPresenceTemplate = this.renderAvatar(person, image, presence);
            personTemplate = html `
        ${imageWithPresenceTemplate}
        ${detailsTemplate}
      `;
        }
        const showPersonCard = this.personCardInteraction !== PersonCardInteraction.none;
        if (showPersonCard) {
            personTemplate = this.renderFlyout(personTemplate, person, image, presence);
        }
        const rootClasses = classMap({
            'person-root': true,
            small: !this.isThreeLines() && !this.isFourLines() && !this.isLargeAvatar(),
            large: this.avatarSize !== 'auto' && this.isLargeAvatar(),
            noline: this.isNoLine(),
            oneline: this.isOneLine(),
            twolines: this.isTwoLines(),
            threelines: this.isThreeLines(),
            fourlines: this.isFourLines(),
            vertical: this.isVertical()
        });
        return html `
      <div
        class="${rootClasses}"
        dir=${this.direction}
        @click=${this.handleMouseClick}
        @mouseenter=${this.handleMouseEnter}
        @mouseleave=${this.handleMouseLeave}
        @keydown=${this.handleKeyDown}
        tabindex="${ifDefined(this.personCardInteraction !== PersonCardInteraction.none ? '0' : undefined)}"
      >
        ${personTemplate}
      </div>
    `;
    }
    /**
     * Render the loading state
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderLoading() {
        return this.renderTemplate('loading', null) || html ``;
    }
    /**
     * Clears state of the component
     *
     * @protected
     * @memberof MgtPerson
     */
    clearState() {
        this._personImage = '';
        this._personDetailsInternal = null;
        this._fetchedImage = null;
        this._fetchedPresence = null;
    }
    /**
     * Render the state when no data is available
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderNoData() {
        const noDataTemplate = this.renderTemplate('no-data', null);
        if (noDataTemplate) {
            return noDataTemplate;
        }
        const avatarClasses = {
            'avatar-icon': true,
            vertical: this.isVertical(),
            small: !this.isLargeAvatar(),
            threeLines: this.isThreeLines(),
            fourLines: this.isFourLines()
        };
        return html `
       <i class=${classMap(avatarClasses)}></i>
     `;
    }
    /**
     * Render a person icon.
     *
     * @protected
     * @returns
     * @memberof MgtPerson
     */
    renderPersonIcon() {
        return getSvg(SvgIcon.Person);
    }
    /**
     * Render the image part of the person template.
     * If the image is unavailable, the person's initials will be used instead.
     *
     * @protected
     * @param {string} [imageSrc]
     * @param {IDynamicPerson} [personDetailsInternal]
     * @returns
     * @memberof MgtPerson
     */
    renderImage(personDetailsInternal, imageSrc) {
        var _a;
        const altText = `${this.strings.photoFor} ${personDetailsInternal.displayName}`;
        const hasImage = imageSrc && !this._isInvalidImageSrc && this.avatarType === avatarType.photo;
        const imageOnly = this.avatarType === avatarType.photo && this.view === ViewType.image;
        const titleText = (_a = ((personDetailsInternal === null || personDetailsInternal === void 0 ? void 0 : personDetailsInternal.displayName) || getEmailFromGraphEntity(personDetailsInternal))) !== null && _a !== void 0 ? _a : undefined;
        const imageTemplate = html `<img
      title="${ifDefined(imageOnly ? titleText : undefined)}"
      alt=${altText}
      src=${imageSrc}
      @error=${() => (this._isInvalidImageSrc = true)} />`;
        const initials = personDetailsInternal ? this.getInitials(personDetailsInternal) : '';
        const hasInitials = initials === null || initials === void 0 ? void 0 : initials.length;
        const textClasses = classMap({
            initials: hasInitials && !hasImage,
            'contact-icon': !hasInitials
        });
        const contactIconTemplate = html `<i>${this.renderPersonIcon()}</i>`;
        // consider the image to presentational if the view is anything other than image.
        // this reduces the redundant announcement of the user's name.
        const textTemplate = html `
      <span 
        title="${ifDefined(this.view === ViewType.image ? titleText : undefined)}"
        role="${ifDefined(this.view === ViewType.image ? undefined : 'presentation')}"
        class="${textClasses}"
      >
        ${hasInitials ? initials : contactIconTemplate}
      </span>
`;
        return hasImage ? imageTemplate : textTemplate;
    }
    /**
     * Render presence for the person.
     *
     * @param presence
     * @memberof MgtPerson
     * @returns
     */
    renderPresence(presence) {
        var _a;
        if (!this.showPresence || !presence) {
            return html ``;
        }
        let presenceIcon;
        const { activity, availability } = presence;
        switch (availability) {
            case 'Available':
            case 'AvailableIdle':
                switch (activity) {
                    case 'OutOfOffice':
                        presenceIcon = getSvg(SvgIcon.PresenceOofAvailable);
                        break;
                    // OutOfOffice and Uknowns
                    case 'Available':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceAvailable);
                        break;
                }
                break;
            case 'Busy':
            case 'BusyIdle':
                switch (activity) {
                    case 'OutOfOffice':
                    case 'OnACall':
                        presenceIcon = getSvg(SvgIcon.PresenceOofBusy);
                        break;
                    // Busy,InACall,InAConferenceCall,InAMeeting, Unknown
                    case 'Busy':
                    case 'InACall':
                    case 'InAMeeting':
                    case 'InAConferenceCall':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceBusy);
                        break;
                }
                break;
            case 'DoNotDisturb':
                switch (activity) {
                    case 'OutOfOffice':
                        presenceIcon = getSvg(SvgIcon.PresenceOofDnd);
                        break;
                    case 'Presenting':
                    case 'Focusing':
                    case 'UrgentInterruptionsOnly':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceDnd);
                        break;
                }
                break;
            case 'Away':
                switch (activity) {
                    case 'OutOfOffice':
                        presenceIcon = getSvg(SvgIcon.PresenceOofAway);
                        break;
                    case 'AwayLastSeenTime':
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceAway);
                        break;
                }
                break;
            case 'BeRightBack':
                switch (activity) {
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceAway);
                        break;
                }
                break;
            case 'Offline':
                switch (activity) {
                    case 'Offline':
                        presenceIcon = getSvg(SvgIcon.PresenceOffline);
                        break;
                    case 'OutOfOffice':
                    case 'OffWork':
                        presenceIcon = getSvg(SvgIcon.PresenceOofAway);
                        break;
                    default:
                        presenceIcon = getSvg(SvgIcon.PresenceStatusUnknown);
                        break;
                }
                break;
            default:
                presenceIcon = getSvg(SvgIcon.PresenceStatusUnknown);
                break;
        }
        const presenceWrapperClasses = classMap({
            'presence-wrapper': true,
            noline: this.isNoLine(),
            oneline: this.isOneLine()
        });
        const formattedActivity = (_a = this.strings[activity]) !== null && _a !== void 0 ? _a : nothing;
        return html `
      <span
        class="${presenceWrapperClasses}"
        title="${formattedActivity}"
        aria-label="${formattedActivity}"
        role="img">
          ${presenceIcon}
      </span>
    `;
    }
    /**
     * Render image with presence for the person.
     *
     * @protected
     * @param
     * @memberof MgtPersonCard
     */
    renderAvatar(personDetailsInternal, image, presence) {
        const hasInitials = !image || this._isInvalidImageSrc || this._avatarType === avatarType.initials;
        let title = '';
        if (hasInitials && personDetailsInternal) {
            title = `${this.strings.initials} ${this.getInitials(personDetailsInternal)}`;
        }
        else {
            title = personDetailsInternal ? personDetailsInternal.displayName || '' : '';
            if (title !== '') {
                title = `${this.strings.photoFor} ${title}`;
            }
        }
        if (title === '') {
            const emailAddress = getEmailFromGraphEntity(personDetailsInternal);
            if (emailAddress !== null) {
                title = `${this.strings.emailAddress} ${emailAddress}`;
            }
        }
        const imageTemplate = this.renderImage(personDetailsInternal, image);
        const presenceTemplate = this.renderPresence(presence);
        return html `
      <div class="avatar-wrapper">
        ${imageTemplate}
        ${presenceTemplate}
      </div>
    `;
    }
    handleLine1Clicked() {
        this.fireCustomEvent('line1clicked', this.personDetailsInternal);
    }
    handleLine2Clicked() {
        this.fireCustomEvent('line2clicked', this.personDetailsInternal);
    }
    handleLine3Clicked() {
        this.fireCustomEvent('line3clicked', this.personDetailsInternal);
    }
    handleLine4Clicked() {
        this.fireCustomEvent('line4clicked', this.personDetailsInternal);
    }
    /**
     * Render the details part of the person template.
     *
     * @param personProps
     * @param presence
     * @memberof MgtPerson
     * @returns
     */
    renderDetails(personProps, presence) {
        if (!personProps || this.view === ViewType.image || this.view === PersonViewType.avatar) {
            return html ``;
        }
        const person = personProps;
        if (presence) {
            person.presenceActivity = presence === null || presence === void 0 ? void 0 : presence.activity;
            person.presenceAvailability = presence === null || presence === void 0 ? void 0 : presence.availability;
        }
        const details = [];
        if (this.view > ViewType.image) {
            const text = this.getTextFromProperty(person, this.line1Property);
            if (this.hasTemplate('line1')) {
                // Render the line1 template
                const template = this.renderTemplate('line1', { person });
                details.push(html `
           <div class="line1" @click=${() => this.handleLine1Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
            }
            else {
                // Render the line1 property value
                if (text) {
                    details.push(html `
             <div class="line1" @click=${() => this.handleLine1Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
                }
            }
        }
        if (this.view > ViewType.oneline) {
            const text = this.getTextFromProperty(person, this.line2Property);
            if (this.hasTemplate('line2')) {
                // Render the line2 template
                const template = this.renderTemplate('line2', { person });
                details.push(html `
           <div class="line2" @click=${() => this.handleLine2Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
            }
            else {
                // Render the line2 property value
                if (text) {
                    details.push(html `
             <div class="line2" @click=${() => this.handleLine2Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
                }
            }
        }
        if (this.view > ViewType.twolines) {
            const text = this.getTextFromProperty(person, this.line3Property);
            if (this.hasTemplate('line3')) {
                // Render the line3 template
                const template = this.renderTemplate('line3', { person });
                details.push(html `
           <div class="line3" @click=${() => this.handleLine3Clicked()} role="presentation" aria-label="${text}">${template}</div>
         `);
            }
            else {
                // Render the line3 property value
                if (text) {
                    details.push(html `
             <div class="line3" @click=${() => this.handleLine3Clicked()} role="presentation" aria-label="${text}">${text}</div>
           `);
                }
            }
        }
        if (this.view > ViewType.threelines) {
            const text = this.getTextFromProperty(person, this.line4Property);
            if (this.hasTemplate('line4')) {
                // Render the line4 template
                const template = this.renderTemplate('line4', { person });
                details.push(html `
          <div class="line4" @click=${() => this.handleLine4Clicked()} role="presentation" aria-label="${text}">${template}</div>
        `);
            }
            else {
                // Render the line4 property value
                if (text) {
                    details.push(html `
            <div class="line4" @click=${() => this.handleLine4Clicked()} role="presentation" aria-label="${text}">${text}</div>
          `);
                }
            }
        }
        const detailsClasses = classMap({
            'details-wrapper': true,
            vertical: this.isVertical()
        });
        return html `
      <div class="${detailsClasses}">
        ${details}
      </div>
    `;
    }
    /**
     * Render the details flyout.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderFlyout(anchor, personDetails, image, presence) {
        const flyoutContent = this._personCardShouldRender
            ? html `
           <div slot="flyout" data-testid="flyout-slot">
             ${this.renderFlyoutContent(personDetails, image, presence)}
           </div>`
            : html ``;
        const slotClasses = classMap({
            vertical: this.isVertical()
        });
        return mgtHtml `
      <mgt-flyout light-dismiss class="flyout" .avoidHidingAnchor=${false}>
        <div slot="anchor" class="${slotClasses}">${anchor}</div>
        ${flyoutContent}
      </mgt-flyout>`;
    }
    /**
     * Render the flyout menu content.
     *
     * @protected
     * @returns {TemplateResult}
     * @memberof MgtPerson
     */
    renderFlyoutContent(personDetails, image, presence) {
        return (this.renderTemplate('person-card', { person: personDetails, personImage: image }) ||
            mgtHtml `
        <mgt-person-card
          class="mgt-person-card"
          lock-tab-navigation
          .personDetails=${personDetails}
          .personImage=${image}
          .personPresence=${presence}
          .showPresence=${this.showPresence}>
        </mgt-person-card>`);
    }
    /**
     * load state into the component.
     *
     * @protected
     * @returns
     * @memberof MgtPerson
     */
    loadState() {
        return __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            if (!provider || provider.state === ProviderState.Loading) {
                return;
            }
            if (provider && provider.state === ProviderState.SignedOut) {
                this.personDetailsInternal = null;
                return;
            }
            const graph = provider.graph.forComponent(this);
            if (this.fallbackDetails) {
                this.line2Property = 'email';
            }
            if (this.verticalLayout && this.view < ViewType.fourlines) {
                this.line2Property = 'email';
            }
            // Prepare person props
            let personProps = [
                ...defaultPersonProperties,
                this.line1Property,
                this.line2Property,
                this.line3Property,
                this.line4Property
            ];
            personProps = personProps.filter(email => email !== 'email');
            let details = this.personDetailsInternal || this.personDetails || this.fallbackDetails;
            if (details) {
                if (!details.personImage &&
                    this.fetchImage &&
                    this._avatarType === avatarType.photo &&
                    !this.personImage &&
                    !this._fetchedImage) {
                    let image;
                    if ('groupTypes' in details) {
                        image = yield getGroupImage(graph, details);
                    }
                    else {
                        image = yield getPersonImage(graph, details, MgtPerson_1.config.useContactApis);
                    }
                    if (image) {
                        details.personImage = image;
                        this._fetchedImage = image;
                    }
                }
            }
            else if (this.userId || this.personQuery === 'me') {
                // Use userId or 'me' query to get the person and image
                let person;
                if (this._avatarType === avatarType.photo && !this.disableImageFetch) {
                    person = yield getUserWithPhoto(graph, this.userId, personProps);
                }
                else {
                    if (this.personQuery === 'me') {
                        person = yield getMe(graph, personProps);
                    }
                    else {
                        person = yield getUser(graph, this.userId, personProps);
                    }
                }
                this.personDetailsInternal = person;
                this.personDetails = person;
                this._fetchedImage = this.getImage();
            }
            else if (this.personQuery) {
                // Use the personQuery to find our person.
                let people = yield findPeople(graph, this.personQuery, 1);
                if (!people || people.length === 0) {
                    people = (yield findUsers(graph, this.personQuery, 1)) || [];
                }
                if (people === null || people === void 0 ? void 0 : people.length) {
                    this.personDetailsInternal = people[0];
                    this.personDetails = people[0];
                    if (this._avatarType === avatarType.photo && !this.disableImageFetch) {
                        const image = yield getPersonImage(graph, people[0], MgtPerson_1.config.useContactApis);
                        if (image) {
                            this.personDetailsInternal.personImage = image;
                            this.personDetails.personImage = image;
                            this._fetchedImage = image;
                        }
                    }
                }
            }
            // populate presence
            const defaultPresence = {
                activity: 'Offline',
                availability: 'Offline',
                id: null
            };
            if (this.showPresence && !this.personPresence && !this._fetchedPresence) {
                try {
                    details = this.personDetailsInternal || this.personDetails;
                    if (details) {
                        // setting userId to 'me' ensures only the presence.read permission is required
                        const userId = this.personQuery !== 'me' ? details === null || details === void 0 ? void 0 : details.id : null;
                        this._fetchedPresence = yield getUserPresence(graph, userId);
                    }
                    else {
                        this._fetchedPresence = defaultPresence;
                    }
                }
                catch (_) {
                    // set up a default Presence in case beta api changes or getting error code
                    this._fetchedPresence = defaultPresence;
                }
            }
        });
    }
    /**
     * Gets the user initials
     *
     * @protected
     * @returns {string}
     * @memberof MgtPerson
     */
    getInitials(person) {
        var _a, _b, _c, _d, _e, _f;
        if (!person) {
            person = this.personDetailsInternal;
        }
        if (isContact(person)) {
            return person.initials;
        }
        let initials = '';
        if (isUser(person)) {
            initials += (_c = (_b = (_a = person.givenName) === null || _a === void 0 ? void 0 : _a[0]) === null || _b === void 0 ? void 0 : _b.toUpperCase()) !== null && _c !== void 0 ? _c : '';
            initials += (_f = (_e = (_d = person.surname) === null || _d === void 0 ? void 0 : _d[0]) === null || _e === void 0 ? void 0 : _e.toUpperCase()) !== null && _f !== void 0 ? _f : '';
        }
        if (!initials && person.displayName) {
            const name = person.displayName.split(/\s+/);
            for (let i = 0; i < 2 && i < name.length; i++) {
                if (name[i][0] && this.isLetter(name[i][0])) {
                    initials += name[i][0].toUpperCase();
                }
            }
        }
        return initials;
    }
    getImage() {
        if (this.personImage) {
            return this.personImage;
        }
        if (this._fetchedImage) {
            return this._fetchedImage;
        }
        const person = this.personDetailsInternal || this.personDetails;
        return (person === null || person === void 0 ? void 0 : person.personImage) ? person.personImage : null;
    }
    isLetter(char) {
        try {
            return char.match(new RegExp('\\p{L}', 'u'));
        }
        catch (e) {
            return char.toLowerCase() !== char.toUpperCase();
        }
    }
    getTextFromProperty(personDetailsInternal, prop) {
        if (!prop || prop.length === 0) {
            return null;
        }
        const properties = prop.trim().split(',');
        let text;
        let i = 0;
        while (!text && i < properties.length) {
            const currentProp = properties[i].trim();
            switch (currentProp) {
                case 'mail':
                case 'email':
                    text = getEmailFromGraphEntity(personDetailsInternal);
                    break;
                default:
                    text = personDetailsInternal[currentProp];
            }
            i++;
        }
        return text;
    }
    isLargeAvatar() {
        return this.avatarSize === 'large' || (this.avatarSize === 'auto' && this.view > ViewType.oneline);
    }
    isNoLine() {
        return this.view < ViewType.oneline;
    }
    isOneLine() {
        return this.view === ViewType.oneline;
    }
    isTwoLines() {
        return this.view === ViewType.twolines;
    }
    isThreeLines() {
        return this.view === ViewType.threelines;
    }
    isFourLines() {
        return this.view === ViewType.fourlines;
    }
    isVertical() {
        return this.verticalLayout;
    }
};
/**
 * Global Configuration object for all
 * person components
 *
 * @static
 * @type {MgtPersonConfig}
 * @memberof MgtPerson
 */
MgtPerson.config = {
    useContactApis: true
};
__decorate([
    property({
        attribute: 'person-query'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "personQuery", null);
__decorate([
    property({
        attribute: 'fallback-details',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "fallbackDetails", null);
__decorate([
    property({
        attribute: 'user-id'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "userId", null);
__decorate([
    property({
        attribute: 'usage'
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "usage", null);
__decorate([
    property({
        attribute: 'show-presence',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "showPresence", void 0);
__decorate([
    property({
        attribute: 'avatar-size',
        type: String
    }),
    __metadata("design:type", String)
], MgtPerson.prototype, "avatarSize", void 0);
__decorate([
    state(),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "personDetailsInternal", null);
__decorate([
    property({
        attribute: 'person-details',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "personDetails", null);
__decorate([
    property({
        attribute: 'person-image',
        type: String
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "personImage", null);
__decorate([
    property({
        attribute: 'fetch-image',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "fetchImage", void 0);
__decorate([
    property({
        attribute: 'disable-image-fetch',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "disableImageFetch", void 0);
__decorate([
    property({
        attribute: 'vertical-layout',
        type: Boolean
    }),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "verticalLayout", void 0);
__decorate([
    property({
        attribute: 'avatar-type',
        converter: (value) => {
            value = value.toLowerCase();
            if (value === 'initials') {
                return avatarType.initials;
            }
            return avatarType.photo;
        }
    }),
    __metadata("design:type", String),
    __metadata("design:paramtypes", [String])
], MgtPerson.prototype, "avatarType", null);
__decorate([
    property({
        attribute: 'person-presence',
        type: Object
    }),
    __metadata("design:type", Object),
    __metadata("design:paramtypes", [Object])
], MgtPerson.prototype, "personPresence", null);
__decorate([
    property({
        attribute: 'person-card',
        converter: value => {
            value = value.toLowerCase();
            if (typeof PersonCardInteraction[value] === 'undefined') {
                return PersonCardInteraction.none;
            }
            else {
                return PersonCardInteraction[value];
            }
        }
    }),
    __metadata("design:type", Number)
], MgtPerson.prototype, "personCardInteraction", void 0);
__decorate([
    property({ attribute: 'line1-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line1Property", void 0);
__decorate([
    property({ attribute: 'line2-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line2Property", void 0);
__decorate([
    property({ attribute: 'line3-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line3Property", void 0);
__decorate([
    property({ attribute: 'line4-property' }),
    __metadata("design:type", String)
], MgtPerson.prototype, "line4Property", void 0);
__decorate([
    property({
        converter: value => {
            if (!value || value.length === 0) {
                return ViewType.image;
            }
            value = value.toLowerCase();
            if (typeof ViewType[value] === 'undefined') {
                return ViewType.image;
            }
            else {
                return ViewType[value];
            }
        }
    }),
    __metadata("design:type", Number)
], MgtPerson.prototype, "view", void 0);
__decorate([
    state(),
    __metadata("design:type", String)
], MgtPerson.prototype, "_fetchedImage", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtPerson.prototype, "_fetchedPresence", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "_isInvalidImageSrc", void 0);
__decorate([
    state(),
    __metadata("design:type", Boolean)
], MgtPerson.prototype, "_personCardShouldRender", void 0);
MgtPerson = MgtPerson_1 = __decorate([
    customElement('person'),
    __metadata("design:paramtypes", [])
], MgtPerson);
export { MgtPerson };
//# sourceMappingURL=mgt-person.js.map