/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { fluentButton, fluentCheckbox, fluentDialog, fluentProgress } from '@fluentui/web-components';
import { customElement, MgtBaseComponent, mgtHtml } from '@microsoft/mgt-element';
import { html } from 'lit';
import { property } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { clearFilesCache, getGraphfile, getUploadSession, sendFileContent, sendFileChunk, deleteSessionFile, isUploadSession } from '../../../graph/graph.files';
import { ViewType } from '../../../graph/types';
import { registerFluentComponents } from '../../../utils/FluentComponents';
import { getSvg, SvgIcon } from '../../../utils/SvgHelper';
import { formatBytes } from '../../../utils/Utils';
import { styles } from './mgt-file-upload-css';
import { strings } from './strings';
registerFluentComponents(fluentProgress, fluentButton, fluentCheckbox, fluentDialog);
/**
 * Type guard for FileSystemDirectoryEntry
 *
 * @param {FileEntry} entry
 * @return {*}  {entry is FileSystemDirectoryEntry}
 */
const isFileSystemDirectoryEntry = (entry) => {
    return entry.isDirectory;
};
/**
 * Type guard for FileSystemDirectoryEntry
 *
 * @param {FileEntry} entry
 * @return {*}  {entry is FileSystemDirectoryEntry}
 */
const isFileSystemFileEntry = (entry) => {
    return entry.isFile;
};
const isFutureDataTransferItem = (item) => 'getAsEntry' in item && typeof item.getAsEntry === 'function';
const isDataTransferItem = (item) => ('getAsFile' in item && typeof item.getAsFile === 'function') ||
    ('webkitGetAsEntry' in item && typeof item.webkitGetAsEntry === 'function');
/**
 * A component to upload files to OneDrive or SharePoint Sites
 *
 * @export
 * @class MgtFileUpload
 * @extends {MgtBaseComponent}
 *
 * @cssprop --file-upload-background-color-drag - {Color} background color of the file list when you upload by drag and drop.
 * @cssprop --file-upload-button-background-color - {Color} background color of the file upload button.
 * @cssprop --file-upload-button-background-color-hover - {Color} background color of the file upload button on hover.
 * @cssprop --file-upload-button-text-color - {Color} text color of the file upload button.
 * @cssprop --file-upload-dialog-background-color - {Color} background color of the file upload dialog box (appears when uploaded files exist).
 * @cssprop --file-upload-dialog-text-color - {Color} text color of the file upload dialog box content.
 * @cssprop --file-upload-dialog-replace-button-background-color - {Color} background color of the replace button in the dialog box.
 * @cssprop --file-upload-dialog-replace-button-background-color-hover - {Color} background color of the replace button in the dialog box when you hover on it.
 * @cssprop --file-upload-dialog-replace-button-text-color - {Color} text color of the replace button in the dialog box.
 * @cssprop --file-upload-dialog-keep-both-button-background-color - {Color} background color of the keep-both button in the dialog box.
 * @cssprop --file-upload-dialog-keep-both-button-background-color-hover - {Color} background color of the keep-both button in the dialog box when you hover on it.
 * @cssprop --file-upload-dialog-keep-both-button-text-color - {Color} text color of the keep-both button in the dialog box.
 * @cssprop --file-upload-border-drag - {String} the border of the file list when you upload files via drag and drop. Default value is 1px dashed #0078d4.
 * @cssprop --file-upload-button-border - {String} the border of the file upload button. Default value is none.
 * @cssprop --file-upload-dialog-replace-button-border - {String} the border of the file upload replace button in the dialog box. Default value is
 * @cssprop --file-upload-dialog-keep-both-button-border - {String} the border of the file upload keep both button in the dialog box. Default value is none.
 * @cssprop --file-upload-dialog-border - {String} the border of the file upload dialog box. Default value is "1px solid var(--neutral-fill-rest)".
 * @cssprop --file-upload-dialog-width - {String} the width of the file upload dialog box. Default value is auto.
 * @cssprop --file-upload-dialog-height - {String} the height of the file upload dialog box. Default value is auto.
 * @cssprop --file-upload-dialog-padding - {String} the padding of the file upload dialog box. Default value is 24px;
 */
let MgtFileUpload = class MgtFileUpload extends MgtBaseComponent {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    get strings() {
        return strings;
    }
    /**
     * Get the scopes required for file upload
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtFileUpload
     */
    static get requiredScopes() {
        return [...new Set(['files.readwrite', 'files.readwrite.all', 'sites.readwrite.all'])];
    }
    // variable avoids removal of files after drag and drop, https://developer.mozilla.org/en-US/docs/Web/API/DataTransfer/dropEffect
    get _dropEffect() {
        return 'copy';
    }
    constructor() {
        super();
        // variable manage drag style when mouse over
        this._dragCounter = 0;
        // variable defined max chuck size "4MB" for large files .
        this._maxChunkSize = 4 * 1024 * 1024;
        this._dialogTitle = '';
        this._dialogContent = '';
        this._dialogPrimaryButton = '';
        this._dialogSecondaryButton = '';
        this._dialogCheckBox = '';
        this._applyAll = false;
        this._applyAllConflictBehavior = null;
        this._maximumFileSize = false;
        this._excludedFileType = false;
        /**
         * Handle the "Upload Files" button click event to open dialog and select files.
         *
         * @param event
         * @returns
         */
        this.onFileUploadChange = (event) => {
            const inputElement = event.target;
            if (!event || inputElement.files.length < 1) {
                return;
            }
            else {
                void this.readUploadedFiles(inputElement.files, () => (inputElement.value = null));
            }
        };
        /**
         * Handle the click event on upload file button that open select files dialog to upload.
         *
         */
        this.onFileUploadClick = () => {
            const uploadInput = this.renderRoot.querySelector('#file-upload-input');
            uploadInput.click();
        };
        /**
         * Stop listeners from onDragOver event.
         *
         * @param event
         */
        this.handleonDragOver = (event) => {
            event.preventDefault();
            event.stopPropagation();
            if (event.dataTransfer.items && event.dataTransfer.items.length > 0) {
                event.dataTransfer.dropEffect = event.dataTransfer.dropEffect = this._dropEffect;
            }
        };
        /**
         * Stop listeners from onDragEnter event, enable drag and drop view.
         *
         * @param event
         */
        this.handleonDragEnter = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this._dragCounter++;
            if (event.dataTransfer.items && event.dataTransfer.items.length > 0) {
                event.dataTransfer.dropEffect = this._dropEffect;
                const dragFileBorder = this.renderRoot.querySelector('#file-upload-border');
                dragFileBorder.classList.add('visible');
            }
        };
        /**
         * Stop listeners from ondragenter event, disable drag and drop view.
         *
         * @param event
         */
        this.handleonDragLeave = (event) => {
            event.preventDefault();
            event.stopPropagation();
            this._dragCounter--;
            if (this._dragCounter === 0) {
                const dragFileBorder = this.renderRoot.querySelector('#file-upload-border');
                dragFileBorder.classList.remove('visible');
            }
        };
        /**
         * Stop listeners from onDrop event and process files.
         *
         * @param event
         */
        this.handleonDrop = (event) => {
            var _a;
            event.preventDefault();
            event.stopPropagation();
            const done = () => {
                event.dataTransfer.clearData();
            };
            const dragFileBorder = this.renderRoot.querySelector('#file-upload-border');
            dragFileBorder.classList.remove('visible');
            if ((_a = event.dataTransfer) === null || _a === void 0 ? void 0 : _a.items) {
                void this.readUploadedFiles(event.dataTransfer.items, done);
            }
            this._dragCounter = 0;
        };
        this.filesToUpload = [];
    }
    /**
     * Render the file upload component
     *
     * @returns
     */
    render() {
        if (this.parentElement !== null) {
            const root = this.parentElement;
            root.addEventListener('dragenter', this.handleonDragEnter);
            root.addEventListener('dragleave', this.handleonDragLeave);
            root.addEventListener('dragover', this.handleonDragOver);
            root.addEventListener('drop', this.handleonDrop);
        }
        return html `
        <div id="file-upload-dialog" class="file-upload-dialog">
          <!-- Modal content -->
          <fluent-dialog modal="true" class="file-upload-dialog-content">
            <span
              class="file-upload-dialog-close"
              id="file-upload-dialog-close">
                ${getSvg(SvgIcon.Cancel)}
            </span>
            <div class="file-upload-dialog-content-text">
              <h2 class="file-upload-dialog-title">${this._dialogTitle}</h2>
              <div>${this._dialogContent}</div>
                <fluent-checkbox
                  id="file-upload-dialog-check"
                  class="file-upload-dialog-check">
                    ${this._dialogCheckBox}
                </fluent-checkbox>
            </div>
            <div class="file-upload-dialog-editor">
              <fluent-button
                appearance="accent"
                class="file-upload-dialog-ok">
                ${this._dialogPrimaryButton}
              </fluent-button>
              <fluent-button
                appearance="outline"
                class="file-upload-dialog-cancel">
                ${this._dialogSecondaryButton}
              </fluent-button>
            </div>
          </fluent-dialog>
        </div>
        <div id="file-upload-border"></div>
        <div class="file-upload-area-button">
          <input
            id="file-upload-input"
            title="${this.strings.uploadButtonLabel}"
            tabindex="-1"
            aria-label="file upload input"
            type="file"
            multiple
            @change="${this.onFileUploadChange}"
          />
          <fluent-button
            appearance="accent"
            class="file-upload-button"
            @click=${this.onFileUploadClick}
            label=${this.strings.uploadButtonLabel}>
              <span slot="start">${getSvg(SvgIcon.Upload)}</span>
              <span class="upload-text">${this.strings.buttonUploadFile}</span>
          </fluent-button>
        </div>
        <div class="file-upload-template">
          ${this.renderFolderTemplate(this.filesToUpload)}
        </div>
       `;
    }
    /**
     * Render Folder structure of files to upload
     *
     * @param fileItems
     * @returns
     */
    renderFolderTemplate(fileItems) {
        const folderStructure = [];
        if (fileItems.length > 0) {
            const templateFileItems = fileItems.map(fileItem => {
                if (folderStructure.indexOf(fileItem.fullPath.substring(0, fileItem.fullPath.lastIndexOf('/'))) === -1) {
                    if (!fileItem.fullPath.endsWith('/')) {
                        folderStructure.push(fileItem.fullPath.substring(0, fileItem.fullPath.lastIndexOf('/')));
                        return mgtHtml `
            <div class='file-upload-table'>
              <div class='file-upload-cell'>
                <mgt-file
                  .fileDetails=${{
                            name: fileItem.fullPath.substring(1, fileItem.fullPath.lastIndexOf('/')),
                            folder: 'Folder'
                        }}
                  .view=${ViewType.oneline}
                  class="mgt-file-item">
                </mgt-file>
              </div>
            </div>
            ${this.renderFileTemplate(fileItem, 'file-upload-folder-tab')}`;
                    }
                    else {
                        return html `${this.renderFileTemplate(fileItem, '')}`;
                    }
                }
                else {
                    return html `${this.renderFileTemplate(fileItem, 'file-upload-folder-tab')}`;
                }
            });
            return html `${templateFileItems}`;
        }
        return html ``;
    }
    /**
     * Render file upload area
     *
     * @param fileItem
     * @returns
     */
    renderFileTemplate(fileItem, folderTabStyle) {
        const completed = classMap({
            'file-upload-table': true,
            upload: fileItem.completed
        });
        const folder = folderTabStyle + (fileItem.fieldUploadResponse === 'lastModifiedDateTime' ? ' file-upload-dialog-success' : '');
        const description = classMap({
            description: fileItem.fieldUploadResponse === 'description'
        });
        const completedTemplate = !fileItem.completed ? this.renderFileUploadTemplate(fileItem) : html ``;
        return mgtHtml `
        <div class="${completed}">
          <div class="${folder}">
            <div class='file-upload-cell'>
              <div class="${description}">
                <div class="file-upload-status">
                  ${fileItem.iconStatus}
                </div>
                <mgt-file
                  .fileDetails=${fileItem.driveItem}
                  .view=${fileItem.view}
                  .line2Property=${fileItem.fieldUploadResponse}
                  part="upload"
                  class="mgt-file-item">
                </mgt-file>
              </div>
            </div>
              ${completedTemplate}
            </div>
          </div>
        </div>`;
    }
    /**
     * Render file upload progress
     *
     * @param fileItem
     * @returns
     */
    renderFileUploadTemplate(fileItem) {
        const completed = classMap({
            'file-upload-table': true,
            upload: fileItem.completed
        });
        return html `
    <div class='file-upload-cell'>
      <div class='file-upload-table file-upload-name'>
        <div class='file-upload-cell'>
          <div
            title="${fileItem.file.name}"
            class='file-upload-filename'>
            ${fileItem.file.name}
          </div>
        </div>
      </div>
      <div class='file-upload-table'>
        <div class='file-upload-cell'>
          <div class="${completed}">
            <fluent-progress class="file-upload-bar" value="${fileItem.percent}"></fluent-progress>
            <div class='file-upload-cell percent-indicator'>
              <span>${fileItem.percent}%</span>
              <span
                class="file-upload-cancel"
                @click=${() => this.deleteFileUploadSession(fileItem)}>
                ${getSvg(SvgIcon.Cancel)}
              </span>
            </div>
          </div>
        </div>
      </div>
    </div>
    `;
    }
    /**
     * Function delete existing file upload sessions
     *
     * @param fileItem
     */
    deleteFileUploadSession(fileItem) {
        return __awaiter(this, void 0, void 0, function* () {
            try {
                if (fileItem.uploadUrl !== undefined) {
                    // Responses that confirm cancelation of session.
                    // 404 means (The upload session was not found/The resource could not be found/)
                    // 409 means The resource has changed since the caller last read it; usually an eTag mismatch
                    yield deleteSessionFile(this.fileUploadList.graph, fileItem.uploadUrl);
                    fileItem.uploadUrl = undefined;
                    fileItem.completed = true;
                    this.setUploadFail(fileItem, strings.cancelUploadFile);
                }
                else {
                    fileItem.uploadUrl = undefined;
                    fileItem.completed = true;
                    this.setUploadFail(fileItem, strings.cancelUploadFile);
                }
            }
            catch (_a) {
                fileItem.uploadUrl = undefined;
                fileItem.completed = true;
                this.setUploadFail(fileItem, strings.cancelUploadFile);
            }
        });
    }
    readUploadedFiles(uploaded, onCompleteCallback) {
        return __awaiter(this, void 0, void 0, function* () {
            const files = yield this.getFilesFromUploadArea(uploaded);
            yield this.getSelectedFiles(files);
            onCompleteCallback();
        });
    }
    /**
     * Get Files and initalize MgtFileUploadItem object life cycle to be uploaded
     *
     * @param inputFiles
     */
    getSelectedFiles(files) {
        return __awaiter(this, void 0, void 0, function* () {
            let fileItems = [];
            const fileItemsCompleted = [];
            this._applyAll = false;
            this._applyAllConflictBehavior = null;
            this._maximumFileSize = false;
            this._excludedFileType = false;
            // Collect ongoing upload files
            this.filesToUpload.forEach(fileItem => {
                if (!fileItem.completed) {
                    fileItems.push(fileItem);
                }
                else {
                    fileItemsCompleted.push(fileItem);
                }
            });
            for (const file of files) {
                const fullPath = file.fullPath === '' ? '/' + file.name : file.fullPath;
                if (fileItems.filter(item => item.fullPath === fullPath).length === 0) {
                    // Initialize variable for File validation
                    let acceptFile = true;
                    // Exclude file based on max file size allowed
                    if (this.fileUploadList.maxFileSize !== undefined && acceptFile) {
                        if (file.size > this.fileUploadList.maxFileSize * 1024) {
                            acceptFile = false;
                            if (this._maximumFileSize === false) {
                                const maximumFileSize = yield this.getFileUploadStatus(file, fullPath, 'MaxFileSize', this.fileUploadList);
                                if (maximumFileSize !== null) {
                                    if (maximumFileSize[0] === 1) {
                                        this._maximumFileSize = true;
                                    }
                                }
                            }
                        }
                    }
                    // Exclude file based on File extensions
                    if (this.fileUploadList.excludedFileExtensions !== undefined) {
                        if (this.fileUploadList.excludedFileExtensions.length > 0 && acceptFile) {
                            if (this.fileUploadList.excludedFileExtensions.filter(fileExtension => {
                                return file.name.toLowerCase().indexOf(fileExtension.toLowerCase()) > -1;
                            }).length > 0) {
                                acceptFile = false;
                                if (this._excludedFileType === false) {
                                    const excludedFileType = yield this.getFileUploadStatus(file, fullPath, 'ExcludedFileType', this.fileUploadList);
                                    if (excludedFileType !== null) {
                                        if (excludedFileType[0] === 1) {
                                            this._excludedFileType = true;
                                        }
                                    }
                                }
                            }
                        }
                    }
                    // Collect accepted files
                    if (acceptFile) {
                        const conflictBehavior = yield this.getFileUploadStatus(file, fullPath, 'Upload', this.fileUploadList);
                        let completed = false;
                        if (conflictBehavior !== null) {
                            if (conflictBehavior[0] === -1) {
                                completed = true;
                            }
                            else {
                                this._applyAll = Boolean(conflictBehavior[0]);
                                this._applyAllConflictBehavior = conflictBehavior[1] ? 1 : 0;
                            }
                        }
                        // Initialize MgtFileUploadItem Life cycle
                        fileItems.push({
                            file,
                            driveItem: {
                                name: file.name
                            },
                            fullPath,
                            conflictBehavior: conflictBehavior !== null ? (conflictBehavior[1] ? 1 : 0) : null,
                            iconStatus: null,
                            percent: 1,
                            view: ViewType.image,
                            completed,
                            maxSize: this._maxChunkSize,
                            minSize: 0
                        });
                    }
                }
            }
            fileItems = fileItems.sort((firstFile, secondFile) => {
                return firstFile.fullPath
                    .substring(0, firstFile.fullPath.lastIndexOf('/'))
                    .localeCompare(secondFile.fullPath.substring(0, secondFile.fullPath.lastIndexOf('/')));
            });
            // remove completed file report image to be reuploaded.
            fileItems.forEach(fileItem => {
                if (fileItemsCompleted.filter(item => item.fullPath === fileItem.fullPath).length !== 0) {
                    const index = fileItemsCompleted.findIndex(item => item.fullPath === fileItem.fullPath);
                    fileItemsCompleted.splice(index, 1);
                }
            });
            fileItems.push(...fileItemsCompleted);
            this.filesToUpload = fileItems;
            // Send multiple Files to upload
            const promises = this.filesToUpload.map(fileItem => this.sendFileItemGraph(fileItem));
            yield Promise.all(promises);
        });
    }
    /**
     * Call modal dialog to replace or keep file.
     *
     * @param file
     * @returns
     */
    getFileUploadStatus(file, fullPath, DialogStatus, fileUploadList) {
        const _super = Object.create(null, {
            requestStateUpdate: { get: () => super.requestStateUpdate }
        });
        return __awaiter(this, void 0, void 0, function* () {
            const fileUploadDialog = this.renderRoot.querySelector('#file-upload-dialog');
            switch (DialogStatus) {
                case 'Upload': {
                    const driveItem = yield getGraphfile(this.fileUploadList.graph, `${this.getGrapQuery(fullPath)}?$select=id`);
                    if (driveItem !== null) {
                        if (this._applyAll === true) {
                            return [this._applyAll, this._applyAllConflictBehavior];
                        }
                        fileUploadDialog.classList.add('visible');
                        this._dialogTitle = strings.fileReplaceTitle;
                        this._dialogContent = strings.fileReplace.replace('{FileName}', file.name);
                        this._dialogCheckBox = strings.checkApplyAll;
                        this._dialogPrimaryButton = strings.buttonReplace;
                        this._dialogSecondaryButton = strings.buttonKeep;
                        yield _super.requestStateUpdate.call(this, true);
                        return new Promise(resolve => {
                            const fileUploadDialogClose = this.renderRoot.querySelector('.file-upload-dialog-close');
                            const fileUploadDialogOk = this.renderRoot.querySelector('.file-upload-dialog-ok');
                            const fileUploadDialogCancel = this.renderRoot.querySelector('.file-upload-dialog-cancel');
                            const fileUploadDialogCheck = this.renderRoot.querySelector('#file-upload-dialog-check');
                            fileUploadDialogCheck.checked = false;
                            fileUploadDialogCheck.classList.remove('hide');
                            // Replace File
                            const onOkDialogClick = () => {
                                fileUploadDialog.classList.remove('visible');
                                resolve([fileUploadDialogCheck.checked ? 1 : 0, 1 /* MgtFileUploadConflictBehavior.replace */]);
                            };
                            // Rename File
                            const onCancelDialogClick = () => {
                                fileUploadDialog.classList.remove('visible');
                                resolve([fileUploadDialogCheck.checked ? 1 : 0, 0 /* MgtFileUploadConflictBehavior.rename */]);
                            };
                            // Cancel File
                            const onCloseDialogClick = () => {
                                fileUploadDialog.classList.remove('visible');
                                resolve([-1]);
                            };
                            // Remove and include event listener to validate options.
                            fileUploadDialogOk.removeEventListener('click', onOkDialogClick);
                            fileUploadDialogCancel.removeEventListener('click', onCancelDialogClick);
                            fileUploadDialogClose.removeEventListener('click', onCloseDialogClick);
                            fileUploadDialogOk.addEventListener('click', onOkDialogClick);
                            fileUploadDialogCancel.addEventListener('click', onCancelDialogClick);
                            fileUploadDialogClose.addEventListener('click', onCloseDialogClick);
                        });
                    }
                    else {
                        return null;
                    }
                    break;
                }
                case 'ExcludedFileType':
                    fileUploadDialog.classList.add('visible');
                    this._dialogTitle = strings.fileTypeTitle;
                    this._dialogContent =
                        strings.fileType.replace('{FileName}', file.name) +
                            ' (' +
                            fileUploadList.excludedFileExtensions.join(',') +
                            ')';
                    this._dialogCheckBox = strings.checkAgain;
                    this._dialogPrimaryButton = strings.buttonOk;
                    this._dialogSecondaryButton = strings.buttonCancel;
                    yield _super.requestStateUpdate.call(this, true);
                    return new Promise(resolve => {
                        const fileUploadDialogOk = this.renderRoot.querySelector('.file-upload-dialog-ok');
                        const fileUploadDialogCancel = this.renderRoot.querySelector('.file-upload-dialog-cancel');
                        const fileUploadDialogClose = this.renderRoot.querySelector('.file-upload-dialog-close');
                        const fileUploadDialogCheck = this.renderRoot.querySelector('#file-upload-dialog-check');
                        fileUploadDialogCheck.checked = false;
                        fileUploadDialogCheck.classList.remove('hide');
                        const onOkDialogClick = () => {
                            fileUploadDialog.classList.remove('visible');
                            // Confirm info
                            resolve([fileUploadDialogCheck.checked ? 1 : 0]);
                        };
                        const onCancelDialogClick = () => {
                            fileUploadDialog.classList.remove('visible');
                            // Cancel all
                            resolve([0]);
                        };
                        // Remove and include event listener to validate options.
                        fileUploadDialogOk.removeEventListener('click', onOkDialogClick);
                        fileUploadDialogCancel.removeEventListener('click', onCancelDialogClick);
                        fileUploadDialogClose.removeEventListener('click', onCancelDialogClick);
                        fileUploadDialogOk.addEventListener('click', onOkDialogClick);
                        fileUploadDialogCancel.addEventListener('click', onCancelDialogClick);
                        fileUploadDialogClose.addEventListener('click', onCancelDialogClick);
                    });
                case 'MaxFileSize':
                    fileUploadDialog.classList.add('visible');
                    this._dialogTitle = strings.maximumFileSizeTitle;
                    this._dialogContent =
                        strings.maximumFileSize
                            .replace('{FileSize}', formatBytes(fileUploadList.maxFileSize * 1024))
                            .replace('{FileName}', file.name) +
                            formatBytes(file.size) +
                            '.';
                    this._dialogCheckBox = strings.checkAgain;
                    this._dialogPrimaryButton = strings.buttonOk;
                    this._dialogSecondaryButton = strings.buttonCancel;
                    yield _super.requestStateUpdate.call(this, true);
                    return new Promise(resolve => {
                        const fileUploadDialogOk = this.renderRoot.querySelector('.file-upload-dialog-ok');
                        const fileUploadDialogCancel = this.renderRoot.querySelector('.file-upload-dialog-cancel');
                        const fileUploadDialogClose = this.renderRoot.querySelector('.file-upload-dialog-close');
                        const fileUploadDialogCheck = this.renderRoot.querySelector('#file-upload-dialog-check');
                        fileUploadDialogCheck.checked = false;
                        fileUploadDialogCheck.classList.remove('hide');
                        const onOkDialogClick = () => {
                            fileUploadDialog.classList.remove('visible');
                            // Confirm info
                            resolve([fileUploadDialogCheck.checked ? 1 : 0]);
                        };
                        const onCancelDialogClick = () => {
                            fileUploadDialog.classList.remove('visible');
                            // Cancel all
                            resolve([0]);
                        };
                        // Remove and include event listener to validate options.
                        fileUploadDialogOk.removeEventListener('click', onOkDialogClick);
                        fileUploadDialogCancel.removeEventListener('click', onCancelDialogClick);
                        fileUploadDialogClose.removeEventListener('click', onCancelDialogClick);
                        fileUploadDialogOk.addEventListener('click', onOkDialogClick);
                        fileUploadDialogCancel.addEventListener('click', onCancelDialogClick);
                        fileUploadDialogClose.addEventListener('click', onCancelDialogClick);
                    });
                default:
                    break;
            }
        });
    }
    /**
     * Get GraphQuery based on pre defined parameters.
     *
     * @param fileItem
     * @returns
     */
    getGrapQuery(fullPath) {
        let itemPath = '';
        if (this.fileUploadList.itemPath) {
            if (this.fileUploadList.itemPath.length > 0) {
                itemPath = this.fileUploadList.itemPath.startsWith('/')
                    ? this.fileUploadList.itemPath
                    : '/' + this.fileUploadList.itemPath;
            }
        }
        // {userId} {itemId}
        if (this.fileUploadList.userId && this.fileUploadList.itemId) {
            return `/users/${this.fileUploadList.userId}/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
        }
        // {userId} {itemPath}
        if (this.fileUploadList.userId && this.fileUploadList.itemPath) {
            return `/users/${this.fileUploadList.userId}/drive/root:${itemPath}${fullPath}`;
        }
        // {groupId} {itemId}
        if (this.fileUploadList.groupId && this.fileUploadList.itemId) {
            return `/groups/${this.fileUploadList.groupId}/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
        }
        // {groupId} {itemPath}
        if (this.fileUploadList.groupId && this.fileUploadList.itemPath) {
            return `/groups/${this.fileUploadList.groupId}/drive/root:${itemPath}${fullPath}`;
        }
        // {driveId} {itemId}
        if (this.fileUploadList.driveId && this.fileUploadList.itemId) {
            return `/drives/${this.fileUploadList.driveId}/items/${this.fileUploadList.itemId}:${fullPath}`;
        }
        // {driveId} {itemPath}
        if (this.fileUploadList.driveId && this.fileUploadList.itemPath) {
            return `/drives/${this.fileUploadList.driveId}/root:${itemPath}${fullPath}`;
        }
        // {siteId} {itemId}
        if (this.fileUploadList.siteId && this.fileUploadList.itemId) {
            return `/sites/${this.fileUploadList.siteId}/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
        }
        // {siteId} {itemPath}
        if (this.fileUploadList.siteId && this.fileUploadList.itemPath) {
            return `/sites/${this.fileUploadList.siteId}/drive/root:${itemPath}${fullPath}`;
        }
        // default OneDrive {itemId}
        if (this.fileUploadList.itemId) {
            return `/me/drive/items/${this.fileUploadList.itemId}:${fullPath}`;
        }
        // default OneDrive {itemPath}
        if (this.fileUploadList.itemPath) {
            return `/me/drive/root:${itemPath}${fullPath}`;
        }
        // default OneDrive root
        return `/me/drive/root:${fullPath}`;
    }
    /**
     * Send file using Upload using Graph based on length
     *
     * @param fileUpload
     * @returns
     */
    sendFileItemGraph(fileItem) {
        return __awaiter(this, void 0, void 0, function* () {
            const graph = this.fileUploadList.graph;
            let graphQuery = '';
            if (fileItem.file.size < this._maxChunkSize) {
                try {
                    if (!fileItem.completed) {
                        if (fileItem.conflictBehavior === null ||
                            fileItem.conflictBehavior === 1 /* MgtFileUploadConflictBehavior.replace */) {
                            graphQuery = `${this.getGrapQuery(fileItem.fullPath)}:/content`;
                        }
                        if (fileItem.conflictBehavior === 0 /* MgtFileUploadConflictBehavior.rename */) {
                            graphQuery = `${this.getGrapQuery(fileItem.fullPath)}:/content?@microsoft.graph.conflictBehavior=rename`;
                        }
                        fileItem.driveItem = yield sendFileContent(graph, graphQuery, fileItem.file);
                        if (fileItem.driveItem !== null) {
                            this.setUploadSuccess(fileItem);
                        }
                        else {
                            fileItem.driveItem = {
                                name: fileItem.file.name
                            };
                            this.setUploadFail(fileItem, strings.failUploadFile);
                        }
                    }
                }
                catch (error) {
                    this.setUploadFail(fileItem, strings.failUploadFile);
                }
            }
            else {
                if (!fileItem.completed) {
                    if (fileItem.uploadUrl === undefined) {
                        const response = yield getUploadSession(graph, `${this.getGrapQuery(fileItem.fullPath)}:/createUploadSession`, fileItem.conflictBehavior);
                        try {
                            if (response !== null) {
                                // uploadSession url used to send chunks of file
                                fileItem.uploadUrl = response.uploadUrl;
                                const driveItem = yield this.sendSessionUrlGraph(graph, fileItem);
                                if (driveItem !== null) {
                                    fileItem.driveItem = driveItem;
                                    this.setUploadSuccess(fileItem);
                                }
                                else {
                                    this.setUploadFail(fileItem, strings.failUploadFile);
                                }
                            }
                            else {
                                this.setUploadFail(fileItem, strings.failUploadFile);
                            }
                            // eslint-disable-next-line no-empty
                        }
                        catch (_a) { }
                    }
                }
            }
        });
    }
    /**
     * Manage slices of File to upload file by chunks using Graph and Session Url
     *
     * @param Graph
     * @param fileItem
     * @returns
     */
    sendSessionUrlGraph(graph, fileItem) {
        const _super = Object.create(null, {
            requestStateUpdate: { get: () => super.requestStateUpdate }
        });
        return __awaiter(this, void 0, void 0, function* () {
            while (fileItem.file.size > fileItem.minSize) {
                if (fileItem.mimeStreamString === undefined) {
                    fileItem.mimeStreamString = (yield this.readFileContent(fileItem.file));
                }
                // Graph client API uses Buffer package to manage ArrayBuffer, change to Blob avoids external package dependency
                const fileSlice = new Blob([fileItem.mimeStreamString.slice(fileItem.minSize, fileItem.maxSize)]);
                fileItem.percent = Math.round((fileItem.maxSize / fileItem.file.size) * 100);
                yield _super.requestStateUpdate.call(this, true);
                if (fileItem.uploadUrl !== undefined) {
                    const response = yield sendFileChunk(graph, fileItem.uploadUrl, `${fileItem.maxSize - fileItem.minSize}`, `bytes ${fileItem.minSize}-${fileItem.maxSize - 1}/${fileItem.file.size}`, fileSlice);
                    if (response === null) {
                        return null;
                    }
                    else if (isUploadSession(response)) {
                        // Define next Chunk
                        fileItem.minSize = parseInt(response.nextExpectedRanges[0].split('-')[0], 10);
                        fileItem.maxSize = fileItem.minSize + this._maxChunkSize;
                        if (fileItem.maxSize > fileItem.file.size) {
                            fileItem.maxSize = fileItem.file.size;
                        }
                    }
                    else if (response.id !== undefined) {
                        return response;
                    }
                }
                else {
                    return null;
                }
            }
        });
    }
    /**
     * Change the state of Mgt-File icon upload to Success
     *
     * @param fileUpload
     */
    setUploadSuccess(fileUpload) {
        fileUpload.percent = 100;
        void super.requestStateUpdate(true);
        setTimeout(() => {
            fileUpload.iconStatus = getSvg(SvgIcon.Success);
            fileUpload.view = ViewType.twolines;
            fileUpload.fieldUploadResponse = 'lastModifiedDateTime';
            fileUpload.completed = true;
            void super.requestStateUpdate(true);
            void clearFilesCache();
        }, 500);
    }
    /**
     * Change the state of Mgt-File icon upload to Fail
     *
     * @param fileUpload
     */
    setUploadFail(fileUpload, errorMessage) {
        setTimeout(() => {
            fileUpload.iconStatus = getSvg(SvgIcon.Fail);
            fileUpload.view = ViewType.twolines;
            fileUpload.driveItem.description = errorMessage;
            fileUpload.fieldUploadResponse = 'description';
            fileUpload.completed = true;
            void super.requestStateUpdate(true);
        }, 500);
    }
    /**
     * Retrieve File content as ArrayBuffer
     *
     * @param file
     * @returns
     */
    readFileContent(file) {
        return new Promise((resolve, reject) => {
            const myReader = new FileReader();
            myReader.onloadend = () => {
                resolve(myReader.result);
            };
            myReader.onerror = e => {
                reject(e);
            };
            myReader.readAsArrayBuffer(file);
        });
    }
    /**
     * Collect Files from Upload Area based on maxUploadFile
     *
     * @param uploadFilesItems
     * @returns
     */
    getFilesFromUploadArea(filesItems) {
        return __awaiter(this, void 0, void 0, function* () {
            const folders = [];
            let entry;
            const collectFilesItems = [];
            for (const uploadFileItem of filesItems) {
                if (isDataTransferItem(uploadFileItem)) {
                    if (isFutureDataTransferItem(uploadFileItem)) {
                        entry = uploadFileItem.getAsEntry();
                        if (isFileSystemDirectoryEntry(entry)) {
                            folders.push(entry);
                        }
                        else {
                            const file = uploadFileItem.getAsFile();
                            if (file) {
                                this.writeFilePath(file, '');
                                collectFilesItems.push(file);
                            }
                        }
                    }
                    else if (uploadFileItem.webkitGetAsEntry) {
                        entry = uploadFileItem.webkitGetAsEntry();
                        if (isFileSystemDirectoryEntry(entry)) {
                            folders.push(entry);
                        }
                        else {
                            const file = uploadFileItem.getAsFile();
                            if (file) {
                                this.writeFilePath(file, '');
                                collectFilesItems.push(file);
                            }
                        }
                    }
                    else {
                        const file = uploadFileItem.getAsFile();
                        if (file) {
                            this.writeFilePath(file, '');
                            collectFilesItems.push(file);
                        }
                    }
                }
                else {
                    this.writeFilePath(uploadFileItem, '');
                    collectFilesItems.push(uploadFileItem);
                }
            }
            // Collect Files from folder
            if (folders.length > 0) {
                const folderFiles = yield this.getFolderFiles(folders);
                collectFilesItems.push(...folderFiles);
            }
            return collectFilesItems;
        });
    }
    /**
     * Retrieve files from folder and subfolders to array.
     *
     * @param folders
     * @returns
     */
    getFolderFiles(folders) {
        return new Promise(resolve => {
            let reading = 0;
            const contents = [];
            folders.forEach(entry => {
                readEntry(entry, '');
            });
            const readEntry = (entry, path) => {
                if (isFileSystemDirectoryEntry(entry)) {
                    readReaderContent(entry.createReader());
                }
                else if (isFileSystemFileEntry(entry)) {
                    reading++;
                    entry.file(file => {
                        reading--;
                        // Include Folder path where File is located
                        this.writeFilePath(file, path);
                        contents.push(file);
                        if (reading === 0) {
                            resolve(contents);
                        }
                    });
                }
            };
            const readReaderContent = (reader) => {
                reading++;
                reader.readEntries(entries => {
                    reading--;
                    for (const entry of entries) {
                        readEntry(entry, entry.fullPath);
                    }
                    if (reading === 0) {
                        resolve(contents);
                    }
                });
            };
        });
    }
    writeFilePath(file, path) {
        file.fullPath = path;
    }
};
__decorate([
    property({ type: Object }),
    __metadata("design:type", Array)
], MgtFileUpload.prototype, "filesToUpload", void 0);
__decorate([
    property({ type: Object }),
    __metadata("design:type", Object)
], MgtFileUpload.prototype, "fileUploadList", void 0);
MgtFileUpload = __decorate([
    customElement('file-upload'),
    __metadata("design:paramtypes", [])
], MgtFileUpload);
export { MgtFileUpload };
//# sourceMappingURL=mgt-file-upload.js.map