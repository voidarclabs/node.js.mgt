/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
/* eslint-disable max-classes-per-file */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { BetaGraph } from '@microsoft/mgt-element';
import { addPlannerTask, assignPeopleToPlannerTask, getAllMyPlannerPlans, getBucketsForPlannerPlan, getPlansForGroup, getSinglePlannerPlan, getTasksForPlannerBucket, removePlannerTask, setPlannerTaskComplete, setPlannerTaskIncomplete } from './mgt-tasks.graph.planner';
import { addTodoTask, getAllMyTodoGroups, getAllTodoTasksForFolder, getFoldersForTodoGroup, getSingleTodoGroup, removeTodoTask, setTodoTaskComplete, setTodoTaskIncomplete } from './mgt-tasks.graph.todo';
/**
 * async method to get user details
 *
 * @class TaskSourceBase
 */
class TaskSourceBase {
    constructor(graph) {
        // Use an instance of BetaGraph since we know we need to call beta apis.
        this.graph = BetaGraph.fromGraph(graph);
    }
}
/**
 * Create Planner
 *
 * @export
 * @class PlannerTaskSource
 * @extends {TaskSourceBase}
 * @implements {ITaskSource}
 */
export class PlannerTaskSource extends TaskSourceBase {
    /**
     * returns promise with all of users plans
     *
     * @returns {Promise<ITaskGroup[]>}
     * @memberof PlannerTaskSource
     */
    getTaskGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            const plans = yield getAllMyPlannerPlans(this.graph);
            return plans.map(plan => { var _a; return ({ id: plan.id, title: plan.title, containerId: (_a = plan === null || plan === void 0 ? void 0 : plan.container) === null || _a === void 0 ? void 0 : _a.containerId }); });
        });
    }
    /**
     * returns promise with all of plans for group id
     *
     * @param {string} id
     * @returns {Promise<ITaskGroup[]>}
     * @memberof PlannerTaskSource
     */
    getTaskGroupsForGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const plans = yield getPlansForGroup(this.graph, id);
            return plans.map(plan => ({ id: plan.id, title: plan.title }));
        });
    }
    /**
     * returns promise single TaskGroup or plan from plan.id
     *
     * @param {string} id
     * @returns {Promise<ITaskGroup>}
     * @memberof PlannerTaskSource
     */
    getTaskGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const plan = yield getSinglePlannerPlan(this.graph, id);
            return { id: plan.id, title: plan.title, _raw: plan };
        });
    }
    /**
     * returns promise with Bucket for a plan from bucket.id
     *
     * @param {string} id
     * @returns {Promise<ITaskFolder[]>}
     * @memberof PlannerTaskSource
     */
    getTaskFoldersForTaskGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const buckets = yield getBucketsForPlannerPlan(this.graph, id);
            return buckets.map(bucket => ({
                _raw: bucket,
                id: bucket.id,
                name: bucket.name,
                parentId: bucket.planId
            }));
        });
    }
    /**
     * get all task from a Bucket given task id
     *
     * @param {string} id
     * @returns {Promise<ITask[]>}
     * @memberof PlannerTaskSource
     */
    getTasksForTaskFolder(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const tasks = yield getTasksForPlannerBucket(this.graph, id);
            return tasks.map(task => ({
                _raw: task,
                assignments: task.assignments,
                completed: task.percentComplete === 100,
                dueDate: task.dueDateTime && new Date(task.dueDateTime),
                eTag: task['@odata.etag'],
                id: task.id,
                immediateParentId: task.bucketId,
                name: task.title,
                topParentId: task.planId
            }));
        });
    }
    /**
     * set task in planner to complete state by id
     *
     * @param {ITask} task
     * @returns {Promise<any>}
     * @memberof PlannerTaskSource
     */
    setTaskComplete(task) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield setPlannerTaskComplete(this.graph, task);
        });
    }
    /**
     * set task in planner to incomplete state by id
     *
     * @param {ITask} task
     * @returns {Promise<any>}
     * @memberof PlannerTaskSource
     */
    setTaskIncomplete(task) {
        return __awaiter(this, void 0, void 0, function* () {
            return setPlannerTaskIncomplete(this.graph, task);
        });
    }
    /**
     * add new task to bucket
     *
     * @param {ITask} newTask
     * @returns {Promise<any>}
     * @memberof PlannerTaskSource
     */
    addTask(newTask) {
        var _a;
        return __awaiter(this, void 0, void 0, function* () {
            return yield addPlannerTask(this.graph, {
                assignments: newTask.assignments,
                bucketId: newTask.immediateParentId,
                dueDateTime: (_a = newTask.dueDate) === null || _a === void 0 ? void 0 : _a.toISOString(),
                planId: newTask.topParentId,
                title: newTask.name
            });
        });
    }
    /**
     * Assigns people to task
     *
     * @param {ITask} task
     * @param {PlannerAssignments} people
     * @returns {Promise<any>}
     * @memberof PlannerTaskSource
     */
    assignPeopleToTask(task, people) {
        return __awaiter(this, void 0, void 0, function* () {
            return assignPeopleToPlannerTask(this.graph, task, people);
        });
    }
    /**
     * remove task from bucket
     *
     * @param {ITask} task
     * @returns {Promise<any>}
     * @memberof PlannerTaskSource
     */
    removeTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield removePlannerTask(this.graph, task);
        });
    }
    /**
     * assigns task to the signed in user
     *
     * @param {ITask} task
     * @param {string} myId
     * @returns {boolean}
     * @memberof PlannerTaskSource
     */
    isAssignedToMe(task, myId) {
        const keys = Object.keys(task.assignments);
        return keys.includes(myId);
    }
}
/**
 * determins outlook task group for data source
 *
 * @export
 * @class TodoTaskSource
 * @extends {TaskSourceBase}
 * @implements {ITaskSource}
 */
export class TodoTaskSource extends TaskSourceBase {
    /**
     * get all Outlook task groups
     *
     * @returns {Promise<ITaskGroup[]>}
     * @memberof TodoTaskSource
     */
    getTaskGroups() {
        return __awaiter(this, void 0, void 0, function* () {
            const groups = yield getAllMyTodoGroups(this.graph);
            return groups.map(group => ({
                _raw: group,
                id: group.id,
                secondaryId: group.groupKey,
                title: group.name
            }));
        });
    }
    /**
     * get a single OutlookTaskGroup from id
     *
     * @param {string} id
     * @returns {Promise<ITaskGroup>}
     * @memberof TodoTaskSource
     */
    getTaskGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const group = yield getSingleTodoGroup(this.graph, id);
            return { id: group.id, secondaryId: group.groupKey, title: group.name, _raw: group };
        });
    }
    /**
     * get all OutlookTaskFolder for group by id
     *
     * @param {string} id
     * @returns {Promise<ITaskFolder[]>}
     * @memberof TodoTaskSource
     */
    getTaskFoldersForTaskGroup(id) {
        return __awaiter(this, void 0, void 0, function* () {
            const folders = yield getFoldersForTodoGroup(this.graph, id);
            return folders.map(folder => ({
                _raw: folder,
                id: folder.id,
                name: folder.name,
                parentId: id
            }));
        });
    }
    /**
     * gets all tasks for OutLook Task Folder by id
     *
     * @param {string} id
     * @param {string} parId
     * @returns {Promise<ITask[]>}
     * @memberof TodoTaskSource
     */
    getTasksForTaskFolder(id, parId) {
        return __awaiter(this, void 0, void 0, function* () {
            const tasks = yield getAllTodoTasksForFolder(this.graph, id);
            return tasks.map(task => ({
                _raw: task,
                assignments: {},
                completed: !!task.completedDateTime,
                dueDate: task.dueDateTime && new Date(task.dueDateTime.dateTime + 'Z'),
                eTag: task['@odata.etag'],
                id: task.id,
                immediateParentId: id,
                name: task.subject,
                topParentId: parId
            }));
        });
    }
    /**
     * set task in todo to complete state by id
     *
     * @param {ITask} task
     * @returns {Promise<any>}
     * @memberof TodoTaskSource
     */
    setTaskComplete(task) {
        return __awaiter(this, void 0, void 0, function* () {
            yield setTodoTaskComplete(this.graph, task.id, task.eTag);
        });
    }
    /**
     * Assigns people to task in a planner
     *
     * @param {ITask} task
     * @param {PlannerAssignments} people
     * @returns {Promise<any>}
     * @memberof PlannerTaskSource
     */
    assignPeopleToTask(task, people) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield assignPeopleToPlannerTask(this.graph, task, people);
        });
    }
    /**
     * set task in planner to incomplete state by id
     *
     * @param {ITask} task
     * @returns {Promise<any>}
     * @memberof TodoTaskSource
     */
    setTaskIncomplete(task) {
        return __awaiter(this, void 0, void 0, function* () {
            yield setTodoTaskIncomplete(this.graph, task.id, task.eTag);
        });
    }
    /**
     * add new task to planner
     *
     * @param {ITask} newTask
     * @returns {Promise<any>}
     * @memberof TodoTaskSource
     */
    addTask(newTask) {
        return __awaiter(this, void 0, void 0, function* () {
            const task = {
                parentFolderId: newTask.immediateParentId,
                subject: newTask.name
            };
            if (newTask.dueDate) {
                task.dueDateTime = {
                    dateTime: newTask.dueDate.toISOString(),
                    timeZone: 'UTC'
                };
            }
            return yield addTodoTask(this.graph, task);
        });
    }
    /**
     * remove task from todo by id
     *
     * @param {ITask} task
     * @returns {Promise<any>}
     * @memberof TodoTaskSource
     */
    removeTask(task) {
        return __awaiter(this, void 0, void 0, function* () {
            return yield removeTodoTask(this.graph, task.id, task.eTag);
        });
    }
    /**
     * if task is assigned in to user logged in
     *
     * @param {ITask} task
     * @param {string} myId
     * @returns {boolean}
     * @memberof TodoTaskSource
     */
    isAssignedToMe(task, myId) {
        const keys = Object.keys(task.assignments);
        return keys.includes(myId);
    }
    /**
     * returns promise with all of plans for group id
     *
     * @param {string} id
     * @returns {Promise<ITaskGroup[]>}
     * @memberof PlannerTaskSource
     */
    getTaskGroupsForGroup(_id) {
        return __awaiter(this, void 0, void 0, function* () {
            return Promise.resolve(undefined);
        });
    }
}
//# sourceMappingURL=task-sources.js.map