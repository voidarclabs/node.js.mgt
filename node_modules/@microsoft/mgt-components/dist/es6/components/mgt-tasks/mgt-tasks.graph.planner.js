/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes } from '@microsoft/mgt-element';
/**
 * async promise, allows developer to create new Planner task
 *
 * @param {IGraph} graph
 * @param {(PlannerTask)} newTask
 * @returns {Promise<any>}
 * @memberof Graph
 */
export const addPlannerTask = (graph, newTask) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield graph
        .api('/planner/tasks')
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes('Group.ReadWrite.All'))
        .post(newTask));
});
/**
 * async promise, allows developer to assign people to task
 *
 * @param {IGraph} graph
 * @param {ITask} task
 * @param {PlannerAssignments} people
 * @returns {Promise<any>}
 * @memberof Graph
 */
export const assignPeopleToPlannerTask = (graph, task, people) => __awaiter(void 0, void 0, void 0, function* () {
    const details = { assignments: people, appliedCategories: { category4: true } };
    yield setPlannerTaskDetails(graph, task, details);
});
/**
 * async promise, allows developer to remove Planner task associated with taskId
 *
 * @param {IGraph} graph
 * @param {ITask} task the task being removed.
 * @returns {Promise<any>}
 * @memberof Graph
 */
export const removePlannerTask = (graph, task) => __awaiter(void 0, void 0, void 0, function* () {
    yield graph
        .api(`/planner/tasks/${task.id}`)
        .header('Cache-Control', 'no-store')
        .header('If-Match', task.eTag)
        .middlewareOptions(prepScopes('Group.ReadWrite.All'))
        .delete();
});
/**
 * async promise, allows developer to set a task to complete, associated with taskId
 *
 * @param {IGraph} graph
 * @param {ITask} task
 * @returns {Promise<any>}
 * @memberof Graph
 */
export const setPlannerTaskComplete = (graph, task) => __awaiter(void 0, void 0, void 0, function* () {
    yield setPlannerTaskDetails(graph, task, { percentComplete: 100 });
});
/**
 * async promise, allows developer to set a task to incomplete, associated with taskId
 *
 * @param {IGraph} graph
 * @param {ITask} task
 * @returns {Promise<any>}
 * @memberof Graph
 */
export const setPlannerTaskIncomplete = (graph, task) => __awaiter(void 0, void 0, void 0, function* () {
    yield setPlannerTaskDetails(graph, task, { percentComplete: 0 });
});
/**
 * async promise, allows developer to set details of planner task associated with a taskId
 *
 * @param {IGraph} graph
 * @param {ITask} task
 * @param {PlannerTask} details
 * @returns {Promise<any>}
 * @memberof Graph
 */
export const setPlannerTaskDetails = (graph, task, details) => __awaiter(void 0, void 0, void 0, function* () {
    let response;
    try {
        response = (yield graph
            .api(`/planner/tasks/${task.id}`)
            .header('Cache-Control', 'no-store')
            .middlewareOptions(prepScopes('Group.ReadWrite.All'))
            .header('Prefer', 'return=representation')
            .header('If-Match', task.eTag)
            .update(details));
    }
    catch (_) {
        /* empty */
    }
    return response;
});
/**
 * async promise, returns all planner plans associated with the group id
 *
 * @param {IGraph} graph
 * @param {string} groupId
 * @returns {(Promise<PlannerPlan[]>)}
 * @memberof Graph
 */
export const getPlansForGroup = (graph, groupId) => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'Group.Read.All';
    const uri = `/groups/${groupId}/planner/plans`;
    const plans = (yield graph
        .api(uri)
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes(scopes))
        .get());
    return plans === null || plans === void 0 ? void 0 : plans.value;
});
/**
 * async promise, returns a single plan from the Graph associated with the planId
 *
 * @param {IGraph} graph
 * @param {string} planId
 * @returns {(Promise<PlannerPlan>)}
 * @memberof Graph
 */
export const getSinglePlannerPlan = (graph, planId) => __awaiter(void 0, void 0, void 0, function* () {
    return (yield graph
        .api(`/planner/plans/${planId}`)
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes('Group.Read.All'))
        .get());
});
/**
 * async promise, returns bucket (for tasks) associated with a planId
 *
 * @param {IGraph} graph
 * @param {string} planId
 * @returns {(Promise<PlannerBucket[]>)}
 * @memberof Graph
 */
export const getBucketsForPlannerPlan = (graph, planId) => __awaiter(void 0, void 0, void 0, function* () {
    const buckets = (yield graph
        .api(`/planner/plans/${planId}/buckets`)
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes('Group.Read.All'))
        .get());
    return buckets === null || buckets === void 0 ? void 0 : buckets.value;
});
/**
 * async promise, returns all planner plans associated with the user logged in
 *
 * @param {IGraph} graph
 * @returns {(Promise<PlannerPlan[]>)}
 * @memberof Graph
 */
export const getAllMyPlannerPlans = (graph) => __awaiter(void 0, void 0, void 0, function* () {
    const plans = (yield graph
        .api('/me/planner/plans')
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes('Group.Read.All'))
        .get());
    return plans === null || plans === void 0 ? void 0 : plans.value;
});
/**
 * async promise, returns all tasks from planner associated with a bucketId
 *
 * @param {IGraph} graph
 * @param {string} bucketId
 * @returns {(Promise<PlannerTask[][]>)}
 * @memberof Graph
 */
export const getTasksForPlannerBucket = (graph, bucketId) => __awaiter(void 0, void 0, void 0, function* () {
    const tasks = (yield graph
        .api(`/planner/buckets/${bucketId}/tasks`)
        .header('Cache-Control', 'no-store')
        .middlewareOptions(prepScopes('Group.Read.All'))
        .get());
    return tasks === null || tasks === void 0 ? void 0 : tasks.value;
});
//# sourceMappingURL=mgt-tasks.graph.planner.js.map