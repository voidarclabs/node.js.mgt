/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __decorate = (this && this.__decorate) || function (decorators, target, key, desc) {
    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;
    if (typeof Reflect === "object" && typeof Reflect.decorate === "function") r = Reflect.decorate(decorators, target, key, desc);
    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;
    return c > 3 && r && Object.defineProperty(target, key, r), r;
};
var __metadata = (this && this.__metadata) || function (k, v) {
    if (typeof Reflect === "object" && typeof Reflect.metadata === "function") return Reflect.metadata(k, v);
};
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { html, nothing } from 'lit';
import { state } from 'lit/decorators.js';
import { classMap } from 'lit/directives/class-map.js';
import { repeat } from 'lit/directives/repeat.js';
import { customElement, mgtHtml } from '@microsoft/mgt-element';
import { Providers, ProviderState } from '@microsoft/mgt-element';
import { getDateString } from '../../utils/Utils';
import { getSvg, SvgIcon } from '../../utils/SvgHelper';
import '../mgt-person/mgt-person';
import { MgtTasksBase } from '../mgt-tasks-base/mgt-tasks-base';
import '../sub-components/mgt-arrow-options/mgt-arrow-options';
import '../sub-components/mgt-dot-options/mgt-dot-options';
import { createTodoTask, deleteTodoTask, getTodoTaskList, getTodoTaskLists, getTodoTasks, updateTodoTask } from './graph.todo';
import { styles } from './mgt-todo-css';
import { strings } from './strings';
import { registerFluentComponents } from '../../utils/FluentComponents';
import { fluentCheckbox, fluentRadioGroup, fluentButton } from '@fluentui/web-components';
import { isElementDark } from '../../utils/isDark';
import { ifDefined } from 'lit/directives/if-defined.js';
registerFluentComponents(fluentCheckbox, fluentRadioGroup, fluentButton);
/**
 * component enables the user to view, add, remove, complete, or edit todo tasks. It works with tasks in Microsoft Planner or Microsoft To-Do.
 *
 * @export
 * @class MgtTodo
 * @extends {MgtTasksBase}
 *
 * @cssprop --task-color - {Color} - Task text color
 * @cssprop --task-background-color - {Color} - Task background color
 * @cssprop --task-complete-background - {Color} - Task background color when completed
 * @cssprop --task-date-input-active-color - {Color} - Task date input active color
 * @cssprop --task-date-input-hover-color - {Color} - Task date input hover color
 * @cssprop --task-background-color-hover - {Color} - Task background when hovered
 * @cssprop --task-box-shadow - {Color} - Task box shadow color
 * @cssprop --task-border-completed - {Color} - Task border color when completed
 * @cssprop --task-radio-background-color - {Color} - Task radio background color
 */
let MgtTodo = class MgtTodo extends MgtTasksBase {
    /**
     * Array of styles to apply to the element. The styles should be defined
     * using the `css` tag function.
     */
    static get styles() {
        return styles;
    }
    /**
     * Strings for localization
     *
     * @readonly
     * @protected
     * @memberof MgtTodo
     */
    get strings() {
        return strings;
    }
    /**
     * Get the scopes required for todo
     *
     * @static
     * @return {*}  {string[]}
     * @memberof MgtTodo
     */
    static get requiredScopes() {
        return ['tasks.read', 'tasks.readwrite'];
    }
    constructor() {
        super();
        this._isDarkMode = false;
        this.onThemeChanged = () => {
            this._isDarkMode = isElementDark(this);
        };
        /**
         * Create a new todo task and add it to the list
         *
         * @protected
         * @returns {Promise<void>}
         * @memberof MgtTodo
         */
        this.addTask = () => __awaiter(this, void 0, void 0, function* () {
            if (this._isNewTaskBeingAdded || !this._newTaskName) {
                return;
            }
            this._isNewTaskBeingAdded = true;
            this.requestUpdate();
            try {
                yield this.createNewTask();
            }
            finally {
                this.clearNewTaskData();
                this._isNewTaskBeingAdded = false;
                this.requestUpdate();
            }
        });
        /**
         * Render the panel for creating a new task
         *
         * @protected
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderNewTask = () => {
            const addIcon = this._newTaskName
                ? html `
        <fluent-checkbox
          class="task-add-icon"
          @click="${this.addTask}">
        </fluent-checkbox>
      `
                : html `
        <span class="add-icon">${getSvg(SvgIcon.Add)}</span>
      `;
            const cancelIcon = html `
      <fluent-button
        aria-label=${this.strings.cancelAddingTask}
        class="task-cancel-icon" 
        @click="${this.clearNewTaskData}"
      >
        ${getSvg(SvgIcon.Cancel)}
      </fluent-button>
    `;
            const dateClass = { dark: this._isDarkMode, date: true };
            const calendarTemplate = html `
      <fluent-text-field
        autocomplete="off"
        type="date"
        id="new-taskDate-input"
        class="${classMap(dateClass)}"
        aria-label="${this.strings.newTaskDateInputLabel}"
        .value="${this.dateToInputValue(this._newTaskDueDate)}"
        @change="${this.handleDateChange}"
      >
      </fluent-text-field>
    `;
            const newTaskDetails = this.readOnly
                ? nothing
                : html `
      <fluent-text-field
        autocomplete="off"
        appearance="outline"
        class="new-task"
        id="new-task-name-input"
        aria-label="${this.strings.newTaskLabel}"
        .value=${this._newTaskName}
        placeholder="${this.strings.newTaskPlaceholder}"
        @keydown="${this.handleKeyDown}"
        @input="${this.handleInput}"
      >
        <div slot="start" class="start">${addIcon}</div>
        ${this._newTaskName
                    ? html `
              <div slot="end" class="end">
                <span class="calendar">${calendarTemplate}</span>
                ${cancelIcon}
              </div> `
                    : html ``}
      </fluent-text-field>
    `;
            return html `
      ${this.currentList
                ? html `
            <div dir=${this.direction} class="task new-task incomplete">
              ${newTaskDetails}
            </div>
        `
                : html ``}  
     `;
        };
        /**
         * Handle a change in taskList.
         *
         * @protected
         * @param {CustomEvent} e
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.handleSelectionChanged = (e) => {
            this.currentList = e.detail;
            void this.loadTasks(this.currentList);
        };
        /**
         * Render task details.
         *
         * @protected
         * @param {TodoTask} task
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderTaskDetails = (task) => {
            const context = { task, list: this.currentList };
            if (this.hasTemplate('task')) {
                return this.renderTemplate('task', context, task.id);
            }
            let taskDetailsTemplate = null;
            const taskDueTemplate = task.dueDateTime
                ? html `
        <span class="task-calendar">${getSvg(SvgIcon.Calendar)}</span>
        <span class="task-due-date">${getDateString(new Date(task.dueDateTime.dateTime))}</span>
      `
                : html ``;
            const taskDeleteTemplate = this.readOnly
                ? html ``
                : html `
        <fluent-button class="task-delete"
          @click="${() => this.removeTask(task.id)}"
          aria-label="${this.strings.deleteTaskLabel}"
        >
          ${getSvg(SvgIcon.Delete)}
        </fluent-button>
      `;
            if (this.hasTemplate('task-details')) {
                taskDetailsTemplate = this.renderTemplate('task-details', context, `task-details-${task.id}`);
            }
            else {
                taskDetailsTemplate = html `
      <div class="task-details">
        <div class="title">${task.title}</div>
        <div class="task-due">${taskDueTemplate}</div>
        ${taskDeleteTemplate}
      </div>
      `;
            }
            return html `${taskDetailsTemplate}`;
        };
        /**
         * Render a task in the list.
         *
         * @protected
         * @param {TodoTask} task
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderTask = (task) => {
            const taskClasses = classMap({
                'read-only': this.readOnly,
                task: true
            });
            return html `
      <fluent-checkbox 
        id=${task.id}
        class=${taskClasses}
        ?disabled=${this.readOnly}
        @click="${() => this.handleTaskCheckClick(task)}"
      >
        ${this.renderTaskDetails(task)}
      </fluent-checkbox>
    `;
        };
        /**
         * Render a completed task in the list.
         *
         * @protected
         * @param {TodoTask} task
         * @returns {TemplateResult}
         * @memberof MgtTodo
         */
        this.renderCompletedTask = (task) => {
            const taskClasses = classMap({
                complete: true,
                'read-only': this.readOnly,
                task: true
            });
            const taskCheckContent = html `${getSvg(SvgIcon.CheckMark)}`;
            return html `
      <fluent-checkbox 
        id=${task.id} 
        class=${taskClasses} 
        checked 
        ?disabled=${this.readOnly} 
        @click="${() => this.handleTaskCheckClick(task)}"
      >
        <div slot="checked-indicator">
          ${taskCheckContent}
        </div>
        ${this.renderTaskDetails(task)}
      </fluent-checkbox>
    `;
        };
        /**
         * loads tasks from dataSource
         *
         * @returns {Promise<void>}
         * @memberof MgtTodo
         */
        this.loadState = () => __awaiter(this, void 0, void 0, function* () {
            const provider = Providers.globalProvider;
            if (!provider || provider.state !== ProviderState.SignedIn) {
                return;
            }
            this._isLoadingTasks = true;
            if (!this._graph) {
                const graph = provider.graph.forComponent(this);
                this._graph = graph;
            }
            if (!this.currentList && !this.initialId) {
                const lists = yield getTodoTaskLists(this._graph);
                const defaultList = lists === null || lists === void 0 ? void 0 : lists.find(l => l.wellknownListName === 'defaultList');
                if (defaultList)
                    yield this.loadTasks(defaultList);
            }
            if (this.targetId) {
                // Call to get the displayName of the list
                this.currentList = yield getTodoTaskList(this._graph, this.targetId);
                this._tasks = yield getTodoTasks(this._graph, this.targetId);
            }
            else if (this.initialId) {
                // Call to get the displayName of the list
                this.currentList = yield getTodoTaskList(this._graph, this.initialId);
                this._tasks = yield getTodoTasks(this._graph, this.initialId);
            }
            this._isLoadingTasks = false;
        });
        /**
         * Clear out the new task metadata input fields
         *
         * @protected
         * @memberof MgtTodo
         */
        this.clearNewTaskData = () => {
            this._newTaskDueDate = null;
            this._newTaskName = '';
        };
        /**
         * Clear the state of the component
         *
         * @protected
         * @memberof MgtTodo
         */
        this.clearState = () => {
            super.clearState();
            this.currentList = null;
            this._tasks = [];
            this._loadingTasks = [];
            this._isLoadingTasks = false;
        };
        this.loadTasks = (list) => __awaiter(this, void 0, void 0, function* () {
            this._isLoadingTasks = true;
            this.currentList = list;
            this._tasks = yield getTodoTasks(this._graph, list.id);
            this._isLoadingTasks = false;
            this.requestUpdate();
        });
        this.updateTaskStatus = (task, taskStatus) => __awaiter(this, void 0, void 0, function* () {
            this._loadingTasks = [...this._loadingTasks, task.id];
            this.requestUpdate();
            // Change the task status
            task.status = taskStatus;
            // Send update request
            const listId = this.currentList.id;
            task = yield updateTodoTask(this._graph, listId, task.id, task);
            const taskIndex = this._tasks.findIndex(t => t.id === task.id);
            this._tasks[taskIndex] = task;
            this._loadingTasks = this._loadingTasks.filter(id => id !== task.id);
            this.requestUpdate();
        });
        this.removeTask = (taskId) => __awaiter(this, void 0, void 0, function* () {
            this._tasks = this._tasks.filter(t => t.id !== taskId);
            this.requestUpdate();
            const listId = this.currentList.id;
            yield deleteTodoTask(this._graph, listId, taskId);
            this._tasks = this._tasks.filter(t => t.id !== taskId);
        });
        this.handleInput = (e) => {
            if (e.target.id === 'new-task-name-input') {
                this._newTaskName = e.target.value;
            }
        };
        this.handleKeyDown = (e) => __awaiter(this, void 0, void 0, function* () {
            if (e.key === 'Enter') {
                yield this.addTask();
            }
        });
        this.handleDateChange = (e) => {
            const value = e.target.value;
            if (value) {
                this._newTaskDueDate = new Date(value + 'T17:00');
            }
            else {
                this._newTaskDueDate = null;
            }
        };
        this._graph = null;
        this._newTaskDueDate = null;
        this._tasks = [];
        this._loadingTasks = [];
        this._isLoadingTasks = false;
        this.addEventListener('selectionChanged', this.handleSelectionChanged);
    }
    /**
     * updates provider state
     *
     * @memberof MgtTasks
     */
    connectedCallback() {
        super.connectedCallback();
        window.addEventListener('darkmodechanged', this.onThemeChanged);
        // invoked to ensure we have the correct initial value for _isDarkMode
        this.onThemeChanged();
    }
    /**
     * removes updates on provider state
     *
     * @memberof MgtTasks
     */
    disconnectedCallback() {
        window.removeEventListener('darkmodechanged', this.onThemeChanged);
        super.disconnectedCallback();
    }
    /**
     * Render the list of todo tasks
     */
    renderTasks() {
        if (this._isLoadingTasks) {
            return this.renderLoadingTask();
        }
        let tasks = this._tasks;
        if (tasks && this.taskFilter) {
            tasks = tasks.filter(task => this.taskFilter(task));
        }
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        const completedTasks = tasks.filter(task => task.status === 'completed');
        const taskTemplates = repeat(
        // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
        tasks.filter(task => task.status !== 'completed'), task => task.id, task => this.renderTask(task));
        const completedTaskTemplates = repeat(completedTasks.sort((a, b) => {
            return new Date(a.lastModifiedDateTime).getTime() - new Date(b.lastModifiedDateTime).getTime();
        }), task => task.id, task => this.renderCompletedTask(task));
        return html `
      ${taskTemplates}
      ${completedTaskTemplates}
    `;
    }
    /**
     * Render the generic picker or the task list displayName.
     *
     */
    renderPicker() {
        var _a, _b;
        if (this.targetId) {
            return html `<p>${(_a = this.currentList) === null || _a === void 0 ? void 0 : _a.displayName}</p>`;
        }
        else {
            return mgtHtml `
        <mgt-picker
          resource="me/todo/lists"
          scopes="tasks.read, tasks.readwrite"
          key-name="displayName"
          selected-value="${ifDefined((_b = this.currentList) === null || _b === void 0 ? void 0 : _b.displayName)}"
          placeholder="Select a task list">
        </mgt-picker>`;
        }
    }
    /**
     * Send a request the Graph to create a new todo task item
     *
     * @protected
     * @returns {Promise<void>}
     * @memberof MgtTodo
     */
    createNewTask() {
        return __awaiter(this, void 0, void 0, function* () {
            const listId = this.currentList.id;
            const taskData = {
                title: this._newTaskName
            };
            if (this._newTaskDueDate) {
                // eslint-disable-next-line @typescript-eslint/dot-notation
                taskData['dueDateTime'] = {
                    dateTime: new Date(this._newTaskDueDate).toLocaleDateString(),
                    timeZone: 'UTC'
                };
            }
            const task = yield createTodoTask(this._graph, listId, taskData);
            this._tasks.unshift(task);
        });
    }
    handleTaskCheckClick(task) {
        this.handleTaskClick(task);
        if (!this.readOnly) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-member-access
            if (task.status === 'completed') {
                void this.updateTaskStatus(task, 'notStarted');
            }
            else {
                void this.updateTaskStatus(task, 'completed');
            }
        }
    }
};
__decorate([
    state(),
    __metadata("design:type", String)
], MgtTodo.prototype, "_newTaskName", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "currentList", void 0);
__decorate([
    state(),
    __metadata("design:type", Object)
], MgtTodo.prototype, "_isDarkMode", void 0);
MgtTodo = __decorate([
    customElement('todo'),
    __metadata("design:paramtypes", [])
], MgtTodo);
export { MgtTodo };
//# sourceMappingURL=mgt-todo.js.map