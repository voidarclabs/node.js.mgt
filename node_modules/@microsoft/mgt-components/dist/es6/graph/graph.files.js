/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { CacheService, GraphPageIterator, prepScopes } from '@microsoft/mgt-element';
import { schemas } from './cacheStores';
import { ResponseType } from '@microsoft/microsoft-graph-client';
import { blobToBase64 } from '../utils/Utils';
/**
 * Simple type guard to check if a response is an UploadSession
 *
 * @param session
 * @returns
 */
export const isUploadSession = (session) => {
    return Array.isArray(session.nextExpectedRanges);
};
/**
 * Clear Cache of FileList
 */
export const clearFilesCache = () => __awaiter(void 0, void 0, void 0, function* () {
    const cache = CacheService.getCache(schemas.fileLists, schemas.fileLists.stores.fileLists);
    yield cache.clearStore();
});
/**
 * Defines the time it takes for objects in the cache to expire
 */
export const getFileInvalidationTime = () => CacheService.config.files.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether or not the cache is enabled
 */
export const getIsFilesCacheEnabled = () => CacheService.config.files.isEnabled && CacheService.config.isEnabled;
/**
 * Defines the time it takes for objects in the cache to expire
 */
export const getFileListInvalidationTime = () => CacheService.config.fileLists.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether or not the cache is enabled
 */
export const getIsFileListsCacheEnabled = () => CacheService.config.fileLists.isEnabled && CacheService.config.isEnabled;
/**
 * Load a DriveItem give and arbitrary query
 *
 * @param graph
 * @param resource
 * @returns
 */
export const getDriveItemByQuery = (graph, resource, storeName = schemas.files.stores.fileQueries, scopes = 'files.read') => __awaiter(void 0, void 0, void 0, function* () {
    // get from cache
    const cache = CacheService.getCache(schemas.files, storeName);
    const cachedFile = yield getFileFromCache(cache, resource);
    if (cachedFile) {
        return cachedFile;
    }
    let response;
    try {
        response = (yield graph.api(resource).middlewareOptions(prepScopes(scopes)).get());
        if (getIsFilesCacheEnabled()) {
            yield cache.putValue(resource, { file: JSON.stringify(response) });
        }
        // eslint-disable-next-line no-empty
    }
    catch (_a) { }
    return response || null;
});
// GET /drives/{drive-id}/items/{item-id}
export const getDriveItemById = (graph, driveId, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/items/${itemId}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.driveFiles);
});
// GET /drives/{drive-id}/root:/{item-path}
export const getDriveItemByPath = (graph, driveId, itemPath) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/root:/${itemPath}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.driveFiles);
});
// GET /groups/{group-id}/drive/items/{item-id}
export const getGroupDriveItemById = (graph, groupId, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/items/${itemId}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.groupFiles);
});
// GET /groups/{group-id}/drive/root:/{item-path}
export const getGroupDriveItemByPath = (graph, groupId, itemPath) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/root:/${itemPath}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.groupFiles);
});
// GET /me/drive/items/{item-id}
export const getMyDriveItemById = (graph, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/me/drive/items/${itemId}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.userFiles);
});
// GET /me/drive/root:/{item-path}
export const getMyDriveItemByPath = (graph, itemPath) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/me/drive/root:/${itemPath}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.userFiles);
});
// GET /sites/{site-id}/drive/items/{item-id}
export const getSiteDriveItemById = (graph, siteId, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/items/${itemId}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.siteFiles);
});
// GET /sites/{site-id}/drive/root:/{item-path}
export const getSiteDriveItemByPath = (graph, siteId, itemPath) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/root:/${itemPath}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.siteFiles);
});
// GET /sites/{site-id}/lists/{list-id}/items/{item-id}/driveItem
export const getListDriveItemById = (graph, siteId, listId, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/lists/${listId}/items/${itemId}/driveItem`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.siteFiles);
});
// GET /users/{user-id}/drive/items/{item-id}
export const getUserDriveItemById = (graph, userId, itemId) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/items/${itemId}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.userFiles);
});
// GET /users/{user-id}/drive/root:/{item-path}
export const getUserDriveItemByPath = (graph, userId, itemPath) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/root:/${itemPath}`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.userFiles);
});
// GET /me/insights/trending/{id}/resource
// GET /me/insights/used/{id}/resource
// GET /me/insights/shared/{id}/resource
export const getMyInsightsDriveItemById = (graph, insightType, id) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/me/insights/${insightType}/${id}/resource`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.insightFiles, 'sites.read.all');
});
// GET /users/{id or userPrincipalName}/insights/{trending or used or shared}/{id}/resource
export const getUserInsightsDriveItemById = (graph, userId, insightType, id) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/insights/${insightType}/${id}/resource`;
    return getDriveItemByQuery(graph, endpoint, schemas.files.stores.insightFiles, 'sites.read.all');
});
const getIterator = (graph, endpoint, storeName, scopes, top) => __awaiter(void 0, void 0, void 0, function* () {
    let filesPageIterator;
    // get iterator from cached values
    const cache = CacheService.getCache(schemas.fileLists, storeName);
    const fileList = yield getFileListFromCache(cache, storeName, `${endpoint}:${top}`);
    if (fileList) {
        filesPageIterator = getFilesPageIteratorFromCache(graph, fileList.files, fileList.nextLink);
        return filesPageIterator;
    }
    // get iterator from graph request
    let request;
    try {
        request = graph.api(endpoint).middlewareOptions(prepScopes(...scopes));
        if (top) {
            request.top(top);
        }
        filesPageIterator = yield getFilesPageIteratorFromRequest(graph, request);
        if (getIsFileListsCacheEnabled()) {
            const nextLink = filesPageIterator.nextLink;
            yield cache.putValue(endpoint, {
                files: filesPageIterator.value.map(v => JSON.stringify(v)),
                nextLink
            });
        }
        // eslint-disable-next-line no-empty
    }
    catch (_b) { }
    return filesPageIterator || null;
});
// GET /me/drive/root/children
export const getFilesIterator = (graph, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = '/me/drive/root/children';
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /drives/{drive-id}/items/{item-id}/children
export const getDriveFilesByIdIterator = (graph, driveId, itemId, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/items/${itemId}/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /drives/{drive-id}/root:/{item-path}:/children
export const getDriveFilesByPathIterator = (graph, driveId, itemPath, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/drives/${driveId}/root:/${itemPath}:/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /groups/{group-id}/drive/items/{item-id}/children
export const getGroupFilesByIdIterator = (graph, groupId, itemId, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/items/${itemId}/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /groups/{group-id}/drive/root:/{item-path}:/children
export const getGroupFilesByPathIterator = (graph, groupId, itemPath, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/groups/${groupId}/drive/root:/${itemPath}:/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /me/drive/items/{item-id}/children
export const getFilesByIdIterator = (graph, itemId, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/me/drive/items/${itemId}/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /me/drive/root:/{item-path}:/children
export const getFilesByPathIterator = (graph, itemPath, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/me/drive/root:/${itemPath}:/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /sites/{site-id}/drive/items/{item-id}/children
export const getSiteFilesByIdIterator = (graph, siteId, itemId, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/items/${itemId}/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /sites/{site-id}/drive/root:/{item-path}:/children
export const getSiteFilesByPathIterator = (graph, siteId, itemPath, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/sites/${siteId}/drive/root:/${itemPath}:/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /users/{user-id}/drive/items/{item-id}/children
export const getUserFilesByIdIterator = (graph, userId, itemId, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/items/${itemId}/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
// GET /users/{user-id}/drive/root:/{item-path}:/children
export const getUserFilesByPathIterator = (graph, userId, itemPath, top) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/users/${userId}/drive/root:/${itemPath}:/children`;
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, endpoint, cacheStore, ['files.read'], top);
});
export const getFilesByListQueryIterator = (graph, listQuery, top) => __awaiter(void 0, void 0, void 0, function* () {
    const cacheStore = schemas.fileLists.stores.fileLists;
    return getIterator(graph, listQuery, cacheStore, ['files.read', 'sites.read.all'], top);
});
// GET /me/insights/{trending	| used | shared}
export const getMyInsightsFiles = (graph, insightType) => __awaiter(void 0, void 0, void 0, function* () {
    const endpoint = `/me/insights/${insightType}`;
    const cacheStore = schemas.fileLists.stores.insightfileLists;
    // get files from cached values
    const cache = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache, cacheStore, endpoint);
    if (fileList) {
        // fileList.files is string[] so JSON.parse to get proper objects
        return fileList.files.map((file) => JSON.parse(file));
    }
    // get files from graph request
    const scopes = ['sites.read.all'];
    let insightResponse;
    try {
        insightResponse = (yield graph
            .api(endpoint)
            .filter("resourceReference/type eq 'microsoft.graph.driveItem'")
            .middlewareOptions(prepScopes(...scopes))
            .get());
        // eslint-disable-next-line no-empty
    }
    catch (_c) { }
    const result = yield getDriveItemsByInsights(graph, insightResponse, scopes);
    if (getIsFileListsCacheEnabled()) {
        yield cache.putValue(endpoint, { files: result.map(file => JSON.stringify(file)) });
    }
    return result || null;
});
// GET /users/{id | userPrincipalName}/insights/{trending	| used | shared}
export const getUserInsightsFiles = (graph, userId, insightType) => __awaiter(void 0, void 0, void 0, function* () {
    let endpoint;
    let filter;
    if (insightType === 'shared') {
        endpoint = '/me/insights/shared';
        filter = `((lastshared/sharedby/id eq '${userId}') and (resourceReference/type eq 'microsoft.graph.driveItem'))`;
    }
    else {
        endpoint = `/users/${userId}/insights/${insightType}`;
        filter = "resourceReference/type eq 'microsoft.graph.driveItem'";
    }
    const key = `${endpoint}?$filter=${filter}`;
    // get files from cached values
    const cacheStore = schemas.fileLists.stores.insightfileLists;
    const cache = CacheService.getCache(schemas.fileLists, cacheStore);
    const fileList = yield getFileListFromCache(cache, cacheStore, key);
    if (fileList) {
        return fileList.files.map((file) => JSON.parse(file));
    }
    // get files from graph request
    const scopes = ['sites.read.all'];
    let insightResponse;
    try {
        insightResponse = (yield graph
            .api(endpoint)
            .filter(filter)
            .middlewareOptions(prepScopes(...scopes))
            .get());
        // eslint-disable-next-line no-empty
    }
    catch (_d) { }
    const result = yield getDriveItemsByInsights(graph, insightResponse, scopes);
    if (getIsFileListsCacheEnabled()) {
        yield cache.putValue(endpoint, { files: result.map(file => JSON.stringify(file)) });
    }
    return result || null;
});
export const getFilesByQueries = (graph, fileQueries) => __awaiter(void 0, void 0, void 0, function* () {
    if (!fileQueries || fileQueries.length === 0) {
        return [];
    }
    const batch = graph.createBatch();
    const files = [];
    const scopes = ['files.read'];
    let cache;
    let cachedFile;
    if (getIsFilesCacheEnabled()) {
        cache = CacheService.getCache(schemas.files, schemas.files.stores.fileQueries);
    }
    for (const fileQuery of fileQueries) {
        if (getIsFilesCacheEnabled()) {
            cachedFile = yield cache.getValue(fileQuery); // todo
        }
        if (getIsFilesCacheEnabled() && cachedFile && getFileInvalidationTime() > Date.now() - cachedFile.timeCached) {
            files.push(JSON.parse(cachedFile.file));
        }
        else if (fileQuery !== '') {
            batch.get(fileQuery, fileQuery, scopes);
        }
    }
    try {
        const responses = yield batch.executeAll();
        for (const fileQuery of fileQueries) {
            const response = responses.get(fileQuery);
            if (response === null || response === void 0 ? void 0 : response.content) {
                files.push(response.content);
                if (getIsFilesCacheEnabled()) {
                    yield cache.putValue(fileQuery, { file: JSON.stringify(response.content) });
                }
            }
        }
        return files;
    }
    catch (_) {
        try {
            return Promise.all(fileQueries
                .filter(fileQuery => fileQuery && fileQuery !== '')
                .map((fileQuery) => __awaiter(void 0, void 0, void 0, function* () {
                const file = yield getDriveItemByQuery(graph, fileQuery);
                if (file) {
                    if (getIsFilesCacheEnabled()) {
                        yield cache.putValue(fileQuery, { file: JSON.stringify(file) });
                    }
                    return file;
                }
            })));
        }
        catch (e) {
            return [];
        }
    }
});
const getDriveItemsByInsights = (graph, insightResponse, scopes) => __awaiter(void 0, void 0, void 0, function* () {
    if (!insightResponse) {
        return [];
    }
    const insightItems = insightResponse.value;
    const batch = graph.createBatch();
    const driveItems = [];
    for (const item of insightItems) {
        const driveItemId = item.resourceReference.id;
        if (driveItemId !== '') {
            batch.get(driveItemId, driveItemId, scopes);
        }
    }
    try {
        const driveItemResponses = yield batch.executeAll();
        for (const item of insightItems) {
            const driveItemResponse = driveItemResponses.get(item.resourceReference.id);
            if (driveItemResponse === null || driveItemResponse === void 0 ? void 0 : driveItemResponse.content) {
                driveItems.push(driveItemResponse.content);
            }
        }
        return driveItems;
    }
    catch (_) {
        try {
            // we're filtering the insights calls that feed this to ensure that only
            // drive items are returned, but we still need to check for nulls
            return Promise.all(insightItems
                .filter(insightItem => Boolean(insightItem.resourceReference.id))
                .map((insightItem) => __awaiter(void 0, void 0, void 0, function* () {
                return (yield graph
                    .api(insightItem.resourceReference.id)
                    .middlewareOptions(prepScopes(...scopes))
                    .get());
            })));
        }
        catch (e) {
            return [];
        }
    }
});
const getFilesPageIteratorFromRequest = (graph, request) => __awaiter(void 0, void 0, void 0, function* () {
    return GraphPageIterator.create(graph, request);
});
const getFilesPageIteratorFromCache = (graph, value, nextLink) => {
    return GraphPageIterator.createFromValue(graph, value.map(v => JSON.parse(v)), nextLink);
};
/**
 * Load a file from the cache
 *
 * @param {CacheStore<CacheFile>} cache
 * @param {string} key
 * @return {*}
 */
const getFileFromCache = (cache, key) => __awaiter(void 0, void 0, void 0, function* () {
    if (getIsFilesCacheEnabled()) {
        const file = yield cache.getValue(key);
        if (file && getFileInvalidationTime() > Date.now() - file.timeCached) {
            // eslint-disable-next-line @typescript-eslint/no-unsafe-return
            return JSON.parse(file.file);
        }
    }
    return null;
});
export const getFileListFromCache = (cache, store, key) => __awaiter(void 0, void 0, void 0, function* () {
    if (!cache) {
        cache = CacheService.getCache(schemas.fileLists, store);
    }
    if (getIsFileListsCacheEnabled()) {
        const fileList = yield cache.getValue(key);
        if (fileList && getFileListInvalidationTime() > Date.now() - fileList.timeCached) {
            return fileList;
        }
    }
    return null;
});
// refresh filesPageIterator to its next iteration and save current page to cache
export const fetchNextAndCacheForFilesPageIterator = (filesPageIterator) => __awaiter(void 0, void 0, void 0, function* () {
    const nextLink = filesPageIterator.nextLink;
    if (filesPageIterator.hasNext) {
        yield filesPageIterator.next();
    }
    if (getIsFileListsCacheEnabled()) {
        const cache = CacheService.getCache(schemas.fileLists, schemas.fileLists.stores.fileLists);
        // match only the endpoint (after version number and before OData query params) e.g. /me/drive/root/children
        const reg = /(graph.microsoft.com\/(v1.0|beta))(.*?)(?=\?)/gi;
        const matches = reg.exec(nextLink);
        const key = matches[3];
        yield cache.putValue(key, { files: filesPageIterator.value.map(v => JSON.stringify(v)), nextLink });
    }
});
/**
 * retrieves the specified document thumbnail
 *
 * @param {string} resource
 * @param {string[]} scopes
 * @returns {Promise<string>}
 */
export const getDocumentThumbnail = (graph, resource, scopes) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        const response = (yield graph
            .api(resource)
            .responseType(ResponseType.RAW)
            .middlewareOptions(prepScopes(...scopes))
            .get());
        if (response.status === 404) {
            // 404 means the resource does not have a thumbnail
            // we still want to cache that state
            // so we return an object that can be cached
            return { eTag: null, thumbnail: null };
        }
        else if (!response.ok) {
            return null;
        }
        const eTag = response.headers.get('eTag');
        const blob = yield blobToBase64(yield response.blob());
        return { eTag, thumbnail: blob };
    }
    catch (e) {
        return null;
    }
});
/**
 * retrieve file properties based on Graph query
 *
 * @param graph
 * @param resource
 * @returns
 */
export const getGraphfile = (graph, resource) => __awaiter(void 0, void 0, void 0, function* () {
    // get from graph request
    const scopes = 'files.read';
    try {
        const response = (yield graph.api(resource).middlewareOptions(prepScopes(scopes)).get());
        return response || null;
        // eslint-disable-next-line no-empty
    }
    catch (_e) { }
    return null;
});
/**
 * retrieve UploadSession Url for large file and send by chuncks
 *
 * @param graph
 * @param resource
 * @returns
 */
export const getUploadSession = (graph, resource, conflictBehavior) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // get from graph request
        const scopes = 'files.readwrite';
        const sessionOptions = {
            item: {
                '@microsoft.graph.conflictBehavior': conflictBehavior === 0 || conflictBehavior === null ? 'rename' : 'replace'
            }
        };
        let response;
        try {
            response = (yield graph
                .api(resource)
                .middlewareOptions(prepScopes(scopes))
                .post(JSON.stringify(sessionOptions)));
            // eslint-disable-next-line no-empty
        }
        catch (_f) { }
        return response || null;
    }
    catch (e) {
        return null;
    }
});
/**
 * send file chunck to OneDrive, SharePoint Site
 *
 * @param graph
 * @param resource
 * @param file
 * @returns
 */
export const sendFileChunk = (graph, resource, contentLength, contentRange, file) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // get from graph request
        const scopes = 'files.readwrite';
        const header = {
            'Content-Length': contentLength,
            'Content-Range': contentRange
        };
        let response;
        try {
            response = (yield graph.client.api(resource).middlewareOptions(prepScopes(scopes)).headers(header).put(file));
            // eslint-disable-next-line no-empty
        }
        catch (_g) { }
        return response || null;
    }
    catch (e) {
        return null;
    }
});
/**
 * send file to OneDrive, SharePoint Site
 *
 * @param graph
 * @param resource
 * @param file
 * @returns
 */
export const sendFileContent = (graph, resource, file) => __awaiter(void 0, void 0, void 0, function* () {
    try {
        // get from graph request
        const scopes = 'files.readwrite';
        let response;
        try {
            response = (yield graph.client.api(resource).middlewareOptions(prepScopes(scopes)).put(file));
            // eslint-disable-next-line no-empty
        }
        catch (_h) { }
        return response || null;
    }
    catch (e) {
        return null;
    }
});
/**
 * delete upload session
 *
 * @param graph
 * @param resource
 * @returns
 */
export const deleteSessionFile = (graph, resource) => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'files.readwrite';
    try {
        yield graph.client.api(resource).middlewareOptions(prepScopes(scopes)).delete();
    }
    catch (_j) {
        // TODO: re-examine the error handling here
        // DELETE returns a 204 on success so void makes sense to return on the happy path
        // but we should probably throw on error
        return null;
    }
});
//# sourceMappingURL=graph.files.js.map