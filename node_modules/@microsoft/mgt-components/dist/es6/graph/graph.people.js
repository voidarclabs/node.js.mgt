/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { extractEmailAddress } from '../utils/Utils';
import { schemas } from './cacheStores';
/**
 * Person Type enum
 *
 * @export
 * @enum {number}
 */
export var PersonType;
(function (PersonType) {
    /**
     * Any type
     */
    PersonType[PersonType["any"] = 0] = "any";
    /**
     * A Person such as User or Contact
     */
    PersonType["person"] = "person";
    /**
     * A group
     */
    PersonType["group"] = "group";
})(PersonType || (PersonType = {}));
/**
 * User Type enum
 *
 * @export
 * @enum {number}
 */
export var UserType;
(function (UserType) {
    /**
     * Any user or contact
     */
    UserType["any"] = "any";
    /**
     * An organization User
     */
    UserType["user"] = "user";
    /**
     * An implicit or personal contact
     */
    UserType["contact"] = "contact";
})(UserType || (UserType = {}));
/**
 * Defines the expiration time
 */
const getPeopleInvalidationTime = () => {
    return CacheService.config.people.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
};
/**
 * Whether the people store is enabled
 */
const getIsPeopleCacheEnabled = () => CacheService.config.people.isEnabled && CacheService.config.isEnabled;
/**
 * async promise, returns all Graph people who are most relevant contacts to the signed in user.
 *
 * @param {string} query
 * @param {number} [top=10] - number of people to return
 * @param {PersonType} [personType=PersonType.person] - the type of person to search for
 * @returns {(Promise<Person[]>)}
 */
export const findPeople = (graph, query, top = 10, userType = UserType.any, filters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'people.read';
    const cacheKey = `${query}:${top}:${userType}`;
    let cache;
    if (getIsPeopleCacheEnabled()) {
        const people = schemas.people;
        const peopleQuery = schemas.people.stores.peopleQuery;
        cache = CacheService.getCache(people, peopleQuery);
        const result = getIsPeopleCacheEnabled() ? yield cache.getValue(cacheKey) : null;
        if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
            return result.results.map(peopleStr => JSON.parse(peopleStr));
        }
    }
    let filter = "personType/class eq 'Person'";
    if (userType !== UserType.any) {
        if (userType === UserType.user) {
            filter += "and personType/subclass eq 'OrganizationUser'";
        }
        else {
            filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
        }
    }
    if (filters !== '') {
        // Adding the default people filters to the search filters
        filter += `${filter} and ${filters}`;
    }
    let graphResult;
    try {
        let graphRequest = graph
            .api('/me/people')
            .search('"' + query + '"')
            .top(top)
            .filter(filter)
            .middlewareOptions(prepScopes(scopes));
        if (userType !== UserType.contact) {
            // for any type other than Contact, user a wider search
            graphRequest = graphRequest.header('X-PeopleQuery-QuerySources', 'Mailbox,Directory');
        }
        graphResult = (yield graphRequest.get());
        if (getIsPeopleCacheEnabled() && graphResult) {
            const item = { maxResults: top, results: null };
            item.results = graphResult.value.map(personStr => JSON.stringify(personStr));
            yield cache.putValue(cacheKey, item);
        }
    }
    catch (error) {
        // intentionally empty
    }
    return graphResult === null || graphResult === void 0 ? void 0 : graphResult.value;
});
/**
 * async promise to the Graph for People, by default, it will request the most frequent contacts for the signed in user.
 *
 * @returns {(Promise<Person[]>)}
 * @memberof Graph
 */
export const getPeople = (graph, userType = UserType.any, peopleFilters = '', top = 10) => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'people.read';
    let cache;
    const cacheKey = `${peopleFilters ? peopleFilters : `*:${userType}`}:${top}`;
    if (getIsPeopleCacheEnabled()) {
        cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
        const cacheRes = yield cache.getValue(cacheKey);
        if (cacheRes && getPeopleInvalidationTime() > Date.now() - cacheRes.timeCached) {
            return cacheRes.results.map(ppl => JSON.parse(ppl));
        }
    }
    const uri = '/me/people';
    let filter = "personType/class eq 'Person'";
    if (userType !== UserType.any) {
        if (userType === UserType.user) {
            filter += "and personType/subclass eq 'OrganizationUser'";
        }
        else {
            filter += "and (personType/subclass eq 'ImplicitContact' or personType/subclass eq 'PersonalContact')";
        }
    }
    if (peopleFilters) {
        filter += ` and ${peopleFilters}`;
    }
    let people;
    try {
        let graphRequest = graph.api(uri).middlewareOptions(prepScopes(scopes)).top(top).filter(filter);
        if (userType !== UserType.contact) {
            // for any type other than Contact, user a wider search
            graphRequest = graphRequest.header('X-PeopleQuery-QuerySources', 'Mailbox,Directory');
        }
        people = (yield graphRequest.get());
        if (getIsPeopleCacheEnabled() && people) {
            yield cache.putValue(cacheKey, { maxResults: 10, results: people.value.map(ppl => JSON.stringify(ppl)) });
        }
    }
    catch (_) {
        // no-op
    }
    return people ? people.value : null;
});
/**
 * Attempts to extract the email from the IDynamicPerson properties.
 *
 * @param {IDynamicperson} entity
 */
export const getEmailFromGraphEntity = (entity) => {
    var _a, _b;
    const person = entity;
    const user = entity;
    const contact = entity;
    if (user.mail) {
        return extractEmailAddress(user.mail);
    }
    else if ((_a = person.scoredEmailAddresses) === null || _a === void 0 ? void 0 : _a.length) {
        return extractEmailAddress(person.scoredEmailAddresses[0].address);
    }
    else if ((_b = contact.emailAddresses) === null || _b === void 0 ? void 0 : _b.length) {
        return extractEmailAddress(contact.emailAddresses[0].address);
    }
    return null;
};
/**
 * async promise, returns a Graph contact associated with the email provided
 *
 * @param {string} email
 * @returns {(Promise<Contact[]>)}
 * @memberof Graph
 */
export const findContactsByEmail = (graph, email) => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'contacts.read';
    let cache;
    if (getIsPeopleCacheEnabled()) {
        cache = CacheService.getCache(schemas.people, schemas.people.stores.contacts);
        const contact = yield cache.getValue(email);
        if (contact && getPeopleInvalidationTime() > Date.now() - contact.timeCached) {
            return JSON.parse(contact.person);
        }
    }
    const encodedEmail = `${email.replace(/#/g, '%2523')}`;
    const result = (yield graph
        .api('/me/contacts')
        .filter(`emailAddresses/any(a:a/address eq '${encodedEmail}')`)
        .middlewareOptions(prepScopes(scopes))
        .get());
    if (getIsPeopleCacheEnabled() && result) {
        yield cache.putValue(email, { person: JSON.stringify(result.value) });
    }
    return result ? result.value : null;
});
/**
 * async promise, returns Graph people matching the Graph query specified
 * in the resource param
 *
 * @param {string} resource
 * @returns {(Promise<Person[]>)}
 * @memberof Graph
 */
export const getPeopleFromResource = (graph, version, resource, scopes) => __awaiter(void 0, void 0, void 0, function* () {
    var _a;
    let cache;
    const key = `${version}${resource}`;
    if (getIsPeopleCacheEnabled()) {
        cache = CacheService.getCache(schemas.people, schemas.people.stores.peopleQuery);
        const result = yield cache.getValue(key);
        if (result && getPeopleInvalidationTime() > Date.now() - result.timeCached) {
            return result.results.map(peopleStr => JSON.parse(peopleStr));
        }
    }
    let request = graph.api(resource).version(version);
    if (scopes === null || scopes === void 0 ? void 0 : scopes.length) {
        request = request.middlewareOptions(prepScopes(...scopes));
    }
    let response = (yield request.get());
    // get more pages if there are available
    if (response && Array.isArray(response.value) && response['@odata.nextLink']) {
        let page = response;
        while (page === null || page === void 0 ? void 0 : page['@odata.nextLink']) {
            const nextLink = page['@odata.nextLink'];
            const nextResource = nextLink.split(version)[1];
            page = (yield graph.client.api(nextResource).version(version).get());
            if ((_a = page === null || page === void 0 ? void 0 : page.value) === null || _a === void 0 ? void 0 : _a.length) {
                page.value = response.value.concat(page.value);
                response = page;
            }
        }
    }
    if (getIsPeopleCacheEnabled() && response) {
        const item = { results: null };
        if (Array.isArray(response.value)) {
            item.results = response.value.map(personStr => JSON.stringify(personStr));
        }
        else {
            item.results = [JSON.stringify(response)];
        }
        yield cache.putValue(key, item);
    }
    return response === null || response === void 0 ? void 0 : response.value;
});
//# sourceMappingURL=graph.people.js.map