{"version":3,"file":"graph.groups.js","sourceRoot":"src/","sources":["graph/graph.groups.ts"],"names":[],"mappings":"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","sourcesContent":["/**\n * -------------------------------------------------------------------------------------------\n * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.\n * See License in the project root for license information.\n * -------------------------------------------------------------------------------------------\n */\n\nimport {\n  IGraph,\n  prepScopes,\n  CacheItem,\n  CacheService,\n  CacheStore,\n  BatchResponse,\n  CollectionResponse\n} from '@microsoft/mgt-element';\nimport { Group } from '@microsoft/microsoft-graph-types';\nimport { schemas } from './cacheStores';\n\n/**\n * Group Type enumeration\n *\n * @export\n * @enum {number}\n */\nexport enum GroupType {\n  /**\n   * Any group Type\n   */\n  any = 0,\n\n  /**\n   * Office 365 group\n   */\n  // eslint-disable-next-line no-bitwise\n  unified = 1 << 0,\n\n  /**\n   * Security group\n   */\n  // eslint-disable-next-line no-bitwise\n  security = 1 << 1,\n\n  /**\n   * Mail Enabled Security group\n   */\n  // eslint-disable-next-line no-bitwise\n  mailenabledsecurity = 1 << 2,\n\n  /**\n   * Distribution Group\n   */\n  // eslint-disable-next-line no-bitwise\n  distribution = 1 << 3\n}\n\n/**\n * Object to be stored in cache\n */\nexport interface CacheGroup extends CacheItem {\n  /**\n   * stringified json representing a user\n   */\n  group?: string;\n}\n\n/**\n * Object to be stored in cache representing individual people\n */\ninterface CacheGroupQuery extends CacheItem {\n  /**\n   * json representing a person stored as string\n   */\n  groups?: string[];\n  /**\n   * top number of results\n   */\n  top?: number;\n}\n\n/**\n * Defines the expiration time\n */\nconst getGroupsInvalidationTime = (): number =>\n  CacheService.config.groups.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;\n\n/**\n * Whether the groups store is enabled\n */\nconst getIsGroupsCacheEnabled = (): boolean => CacheService.config.groups.isEnabled && CacheService.config.isEnabled;\n\n/**\n * Searches the Graph for Groups\n *\n * @export\n * @param {IGraph} graph\n * @param {string} query - what to search for\n * @param {number} [top=10] - number of groups to return\n * @param {GroupType} [groupTypes=GroupType.any] - the type of group to search for\n * @returns {Promise<Group[]>} An array of Groups\n */\nexport const findGroups = async (\n  graph: IGraph,\n  query: string,\n  top = 10,\n  groupTypes: GroupType = GroupType.any,\n  groupFilters = ''\n): Promise<Group[]> => {\n  const scopes = 'Group.Read.All';\n\n  let cache: CacheStore<CacheGroupQuery>;\n  const key = `${query ? query : '*'}*${groupTypes}*${groupFilters}:${top}`;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);\n    const cacheGroupQuery = await cache.getValue(key);\n    if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {\n      if (cacheGroupQuery.top >= top) {\n        // if request is less than the cache's requests, return a slice of the results\n        return cacheGroupQuery.groups.map(x => JSON.parse(x) as Group).slice(0, top + 1);\n      }\n      // if the new request needs more results than what's presently in the cache, graph must be called again\n    }\n  }\n\n  let filterQuery = '';\n  let responses: Map<string, BatchResponse<CollectionResponse<Group>>>;\n  const batchedResult: Group[] = [];\n\n  if (query !== '') {\n    filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;\n  }\n\n  if (groupFilters) {\n    filterQuery += `${query ? ' and ' : ''}${groupFilters}`;\n  }\n\n  if (groupTypes !== GroupType.any) {\n    const batch = graph.createBatch<CollectionResponse<Group>>();\n\n    const filterGroups: string[] = [];\n\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison, no-bitwise\n    if (GroupType.unified === (groupTypes & GroupType.unified)) {\n      filterGroups.push(\"groupTypes/any(c:c+eq+'Unified')\");\n    }\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.security === (groupTypes & GroupType.security)) {\n      filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');\n    }\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');\n    }\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.distribution === (groupTypes & GroupType.distribution)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');\n    }\n\n    filterQuery = filterQuery ? `${filterQuery} and ` : '';\n    for (const filter of filterGroups) {\n      batch.get(filter, `/groups?$filter=${filterQuery + filter}`, ['Group.Read.All']);\n    }\n\n    try {\n      responses = await batch.executeAll();\n\n      for (const filterGroup of filterGroups) {\n        if (responses.get(filterGroup).content.value) {\n          for (const group of responses.get(filterGroup).content.value) {\n            const repeat = batchedResult.find(batchedGroup => batchedGroup.id === group.id);\n            if (!repeat) {\n              batchedResult.push(group);\n            }\n          }\n        }\n      }\n    } catch (_) {\n      try {\n        const queries: Promise<CollectionResponse<Group>>[] = [];\n        for (const filter of filterGroups) {\n          queries.push(\n            graph\n              .api('groups')\n              .filter(`${filterQuery} and ${filter}`)\n              .top(top)\n              .count(true)\n              .header('ConsistencyLevel', 'eventual')\n              .middlewareOptions(prepScopes(scopes))\n              .get() as Promise<CollectionResponse<Group>>\n          );\n        }\n        return (await Promise.all(queries)).map(x => x.value).reduce((a, b) => a.concat(b), []);\n      } catch (e) {\n        return [];\n      }\n    }\n  } else {\n    if (batchedResult.length === 0) {\n      const result = (await graph\n        .api('groups')\n        .filter(filterQuery)\n        .top(top)\n        .count(true)\n        .header('ConsistencyLevel', 'eventual')\n        .middlewareOptions(prepScopes(scopes))\n        .get()) as CollectionResponse<Group>;\n      if (getIsGroupsCacheEnabled() && result) {\n        await cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top });\n      }\n      return result ? result.value : null;\n    }\n  }\n\n  return batchedResult;\n};\n\n/**\n * Searches the Graph for group members\n *\n * @export\n * @param {IGraph} graph\n * @param {string} query - what to search for\n * @param {string} groupId - what to search for\n * @param {number} [top=10] - number of groups to return\n * @param {boolean} [transitive=false] - whether the return should contain a flat list of all nested members\n * @param {GroupType} [groupTypes=GroupType.any] - the type of group to search for\n * @returns {Promise<Group[]>} An array of Groups\n */\nexport const findGroupsFromGroup = async (\n  graph: IGraph,\n  query: string,\n  groupId: string,\n  top = 10,\n  transitive = false,\n  groupTypes: GroupType = GroupType.any\n): Promise<Group[]> => {\n  const scopes = 'Group.Read.All';\n\n  let cache: CacheStore<CacheGroupQuery>;\n  const key = `${groupId}:${query || '*'}:${groupTypes}:${transitive}`;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);\n    const cacheGroupQuery = await cache.getValue(key);\n    if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {\n      if (cacheGroupQuery.top >= top) {\n        // if request is less than the cache's requests, return a slice of the results\n        return cacheGroupQuery.groups.map(x => JSON.parse(x) as Group).slice(0, top + 1);\n      }\n      // if the new request needs more results than what's presently in the cache, graph must be called again\n    }\n  }\n\n  const apiUrl = `groups/${groupId}/${transitive ? 'transitiveMembers' : 'members'}/microsoft.graph.group`;\n  let filterQuery = '';\n  if (query !== '') {\n    filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;\n  }\n\n  if (groupTypes !== GroupType.any) {\n    const filterGroups = [];\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.unified === (groupTypes & GroupType.unified)) {\n      filterGroups.push(\"groupTypes/any(c:c+eq+'Unified')\");\n    }\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.security === (groupTypes & GroupType.security)) {\n      filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');\n    }\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');\n    }\n\n    // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison\n    if (GroupType.distribution === (groupTypes & GroupType.distribution)) {\n      filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');\n    }\n\n    filterQuery += (query !== '' ? ' and ' : '') + filterGroups.join(' or ');\n  }\n\n  const result = (await graph\n    .api(apiUrl)\n    .filter(filterQuery)\n    .count(true)\n    .top(top)\n    .header('ConsistencyLevel', 'eventual')\n    .middlewareOptions(prepScopes(scopes))\n    .get()) as CollectionResponse<Group>;\n\n  if (getIsGroupsCacheEnabled() && result) {\n    await cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top });\n  }\n\n  return result ? result.value : null;\n};\n\n/**\n * async promise, returns all Graph groups associated with the id provided\n *\n * @param {string} id\n * @returns {(Promise<User>)}\n * @memberof Graph\n */\nexport const getGroup = async (graph: IGraph, id: string, requestedProps?: string[]): Promise<Group> => {\n  const scopes = 'Group.Read.All';\n  let cache: CacheStore<CacheGroup>;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);\n    // check cache\n    const group = await cache.getValue(id);\n\n    // is it stored and is timestamp good?\n    if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {\n      const cachedData = group.group ? (JSON.parse(group.group) as Group) : null;\n      const uniqueProps =\n        requestedProps && cachedData ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop)) : null;\n\n      // return without any worries\n      if (!uniqueProps || uniqueProps.length <= 1) {\n        return cachedData;\n      }\n    }\n  }\n\n  let apiString = `/groups/${id}`;\n  if (requestedProps) {\n    apiString = apiString + '?$select=' + requestedProps.toString();\n  }\n\n  // else we must grab it\n  const response = (await graph.api(apiString).middlewareOptions(prepScopes(scopes)).get()) as Group;\n  if (getIsGroupsCacheEnabled()) {\n    await cache.putValue(id, { group: JSON.stringify(response) });\n  }\n  return response;\n};\n\n/**\n * Returns a Promise of Graph Groups array associated with the groupIds array\n *\n * @export\n * @param {IGraph} graph\n * @param {string[]} groupIds, an array of string ids\n * @returns {Promise<Group[]>}\n */\nexport const getGroupsForGroupIds = async (graph: IGraph, groupIds: string[], filters = ''): Promise<Group[]> => {\n  if (!groupIds || groupIds.length === 0) {\n    return [];\n  }\n  const batch = graph.createBatch();\n  const groupDict: Record<string, Group | Promise<Group>> = {};\n  const notInCache: string[] = [];\n  let cache: CacheStore<CacheGroup>;\n\n  if (getIsGroupsCacheEnabled()) {\n    cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);\n  }\n\n  for (const id of groupIds) {\n    groupDict[id] = null;\n    let group: CacheGroup;\n    if (getIsGroupsCacheEnabled()) {\n      group = await cache.getValue(id);\n    }\n    if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {\n      groupDict[id] = group.group ? (JSON.parse(group.group) as Group) : null;\n    } else if (id !== '') {\n      let apiUrl = `/groups/${id}`;\n      if (filters) {\n        apiUrl = `${apiUrl}?$filters=${filters}`;\n      }\n      batch.get(id, apiUrl, ['Group.Read.All']);\n      notInCache.push(id);\n    }\n  }\n  try {\n    const responses = await batch.executeAll();\n    // iterate over groupIds to ensure the order of ids\n    for (const id of groupIds) {\n      const response = responses.get(id);\n      if (response?.content) {\n        groupDict[id] = response.content as Group;\n        if (getIsGroupsCacheEnabled()) {\n          await cache.putValue(id, { group: JSON.stringify(response.content) });\n        }\n      }\n    }\n    return Promise.all(Object.values(groupDict));\n  } catch (_) {\n    // fallback to making the request one by one\n    try {\n      // call getGroup for all the users that weren't cached\n      groupIds\n        .filter(id => notInCache.includes(id))\n        .forEach(id => {\n          groupDict[id] = getGroup(graph, id);\n        });\n      if (getIsGroupsCacheEnabled()) {\n        // store all users that weren't retrieved from the cache, into the cache\n        await Promise.all(\n          groupIds\n            .filter(id => notInCache.includes(id))\n            .map(async id => await cache.putValue(id, { group: JSON.stringify(await groupDict[id]) }))\n        );\n      }\n      return Promise.all(Object.values(groupDict));\n    } catch (e) {\n      return [];\n    }\n  }\n};\n\n/**\n * Gets groups from the graph that are in the group ids\n *\n * @param graph\n * @param query\n * @param groupId\n * @param top\n * @param transitive\n * @param groupTypes\n * @param filters\n * @returns\n */\nexport const findGroupsFromGroupIds = async (\n  graph: IGraph,\n  query: string,\n  groupIds: string[],\n  top = 10,\n  groupTypes: GroupType = GroupType.any,\n  filters = ''\n): Promise<Group[]> => {\n  const foundGroups: Group[] = [];\n  const graphGroups = await findGroups(graph, query, top, groupTypes, filters);\n  if (graphGroups) {\n    for (const group of graphGroups) {\n      if (group.id && groupIds.includes(group.id)) {\n        foundGroups.push(group);\n      }\n    }\n  }\n  return foundGroups;\n};\n"]}