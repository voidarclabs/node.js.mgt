/**
 * -------------------------------------------------------------------------------------------
 * Copyright (c) Microsoft Corporation.  All Rights Reserved.  Licensed under the MIT License.
 * See License in the project root for license information.
 * -------------------------------------------------------------------------------------------
 */
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
import { prepScopes, CacheService } from '@microsoft/mgt-element';
import { schemas } from './cacheStores';
/**
 * Group Type enumeration
 *
 * @export
 * @enum {number}
 */
export var GroupType;
(function (GroupType) {
    /**
     * Any group Type
     */
    GroupType[GroupType["any"] = 0] = "any";
    /**
     * Office 365 group
     */
    // eslint-disable-next-line no-bitwise
    GroupType[GroupType["unified"] = 1] = "unified";
    /**
     * Security group
     */
    // eslint-disable-next-line no-bitwise
    GroupType[GroupType["security"] = 2] = "security";
    /**
     * Mail Enabled Security group
     */
    // eslint-disable-next-line no-bitwise
    GroupType[GroupType["mailenabledsecurity"] = 4] = "mailenabledsecurity";
    /**
     * Distribution Group
     */
    // eslint-disable-next-line no-bitwise
    GroupType[GroupType["distribution"] = 8] = "distribution";
})(GroupType || (GroupType = {}));
/**
 * Defines the expiration time
 */
const getGroupsInvalidationTime = () => CacheService.config.groups.invalidationPeriod || CacheService.config.defaultInvalidationPeriod;
/**
 * Whether the groups store is enabled
 */
const getIsGroupsCacheEnabled = () => CacheService.config.groups.isEnabled && CacheService.config.isEnabled;
/**
 * Searches the Graph for Groups
 *
 * @export
 * @param {IGraph} graph
 * @param {string} query - what to search for
 * @param {number} [top=10] - number of groups to return
 * @param {GroupType} [groupTypes=GroupType.any] - the type of group to search for
 * @returns {Promise<Group[]>} An array of Groups
 */
export const findGroups = (graph, query, top = 10, groupTypes = GroupType.any, groupFilters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'Group.Read.All';
    let cache;
    const key = `${query ? query : '*'}*${groupTypes}*${groupFilters}:${top}`;
    if (getIsGroupsCacheEnabled()) {
        cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);
        const cacheGroupQuery = yield cache.getValue(key);
        if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {
            if (cacheGroupQuery.top >= top) {
                // if request is less than the cache's requests, return a slice of the results
                return cacheGroupQuery.groups.map(x => JSON.parse(x)).slice(0, top + 1);
            }
            // if the new request needs more results than what's presently in the cache, graph must be called again
        }
    }
    let filterQuery = '';
    let responses;
    const batchedResult = [];
    if (query !== '') {
        filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;
    }
    if (groupFilters) {
        filterQuery += `${query ? ' and ' : ''}${groupFilters}`;
    }
    if (groupTypes !== GroupType.any) {
        const batch = graph.createBatch();
        const filterGroups = [];
        // eslint-disable-next-line @typescript-eslint/no-unsafe-enum-comparison, no-bitwise
        if (GroupType.unified === (groupTypes & GroupType.unified)) {
            filterGroups.push("groupTypes/any(c:c+eq+'Unified')");
        }
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.security === (groupTypes & GroupType.security)) {
            filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');
        }
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {
            filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');
        }
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.distribution === (groupTypes & GroupType.distribution)) {
            filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');
        }
        filterQuery = filterQuery ? `${filterQuery} and ` : '';
        for (const filter of filterGroups) {
            batch.get(filter, `/groups?$filter=${filterQuery + filter}`, ['Group.Read.All']);
        }
        try {
            responses = yield batch.executeAll();
            for (const filterGroup of filterGroups) {
                if (responses.get(filterGroup).content.value) {
                    for (const group of responses.get(filterGroup).content.value) {
                        const repeat = batchedResult.find(batchedGroup => batchedGroup.id === group.id);
                        if (!repeat) {
                            batchedResult.push(group);
                        }
                    }
                }
            }
        }
        catch (_) {
            try {
                const queries = [];
                for (const filter of filterGroups) {
                    queries.push(graph
                        .api('groups')
                        .filter(`${filterQuery} and ${filter}`)
                        .top(top)
                        .count(true)
                        .header('ConsistencyLevel', 'eventual')
                        .middlewareOptions(prepScopes(scopes))
                        .get());
                }
                return (yield Promise.all(queries)).map(x => x.value).reduce((a, b) => a.concat(b), []);
            }
            catch (e) {
                return [];
            }
        }
    }
    else {
        if (batchedResult.length === 0) {
            const result = (yield graph
                .api('groups')
                .filter(filterQuery)
                .top(top)
                .count(true)
                .header('ConsistencyLevel', 'eventual')
                .middlewareOptions(prepScopes(scopes))
                .get());
            if (getIsGroupsCacheEnabled() && result) {
                yield cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top });
            }
            return result ? result.value : null;
        }
    }
    return batchedResult;
});
/**
 * Searches the Graph for group members
 *
 * @export
 * @param {IGraph} graph
 * @param {string} query - what to search for
 * @param {string} groupId - what to search for
 * @param {number} [top=10] - number of groups to return
 * @param {boolean} [transitive=false] - whether the return should contain a flat list of all nested members
 * @param {GroupType} [groupTypes=GroupType.any] - the type of group to search for
 * @returns {Promise<Group[]>} An array of Groups
 */
export const findGroupsFromGroup = (graph, query, groupId, top = 10, transitive = false, groupTypes = GroupType.any) => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'Group.Read.All';
    let cache;
    const key = `${groupId}:${query || '*'}:${groupTypes}:${transitive}`;
    if (getIsGroupsCacheEnabled()) {
        cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groupsQuery);
        const cacheGroupQuery = yield cache.getValue(key);
        if (cacheGroupQuery && getGroupsInvalidationTime() > Date.now() - cacheGroupQuery.timeCached) {
            if (cacheGroupQuery.top >= top) {
                // if request is less than the cache's requests, return a slice of the results
                return cacheGroupQuery.groups.map(x => JSON.parse(x)).slice(0, top + 1);
            }
            // if the new request needs more results than what's presently in the cache, graph must be called again
        }
    }
    const apiUrl = `groups/${groupId}/${transitive ? 'transitiveMembers' : 'members'}/microsoft.graph.group`;
    let filterQuery = '';
    if (query !== '') {
        filterQuery = `(startswith(displayName,'${query}') or startswith(mailNickname,'${query}') or startswith(mail,'${query}'))`;
    }
    if (groupTypes !== GroupType.any) {
        const filterGroups = [];
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.unified === (groupTypes & GroupType.unified)) {
            filterGroups.push("groupTypes/any(c:c+eq+'Unified')");
        }
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.security === (groupTypes & GroupType.security)) {
            filterGroups.push('(mailEnabled eq false and securityEnabled eq true)');
        }
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.mailenabledsecurity === (groupTypes & GroupType.mailenabledsecurity)) {
            filterGroups.push('(mailEnabled eq true and securityEnabled eq true)');
        }
        // eslint-disable-next-line no-bitwise, @typescript-eslint/no-unsafe-enum-comparison
        if (GroupType.distribution === (groupTypes & GroupType.distribution)) {
            filterGroups.push('(mailEnabled eq true and securityEnabled eq false)');
        }
        filterQuery += (query !== '' ? ' and ' : '') + filterGroups.join(' or ');
    }
    const result = (yield graph
        .api(apiUrl)
        .filter(filterQuery)
        .count(true)
        .top(top)
        .header('ConsistencyLevel', 'eventual')
        .middlewareOptions(prepScopes(scopes))
        .get());
    if (getIsGroupsCacheEnabled() && result) {
        yield cache.putValue(key, { groups: result.value.map(x => JSON.stringify(x)), top });
    }
    return result ? result.value : null;
});
/**
 * async promise, returns all Graph groups associated with the id provided
 *
 * @param {string} id
 * @returns {(Promise<User>)}
 * @memberof Graph
 */
export const getGroup = (graph, id, requestedProps) => __awaiter(void 0, void 0, void 0, function* () {
    const scopes = 'Group.Read.All';
    let cache;
    if (getIsGroupsCacheEnabled()) {
        cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);
        // check cache
        const group = yield cache.getValue(id);
        // is it stored and is timestamp good?
        if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {
            const cachedData = group.group ? JSON.parse(group.group) : null;
            const uniqueProps = requestedProps && cachedData ? requestedProps.filter(prop => !Object.keys(cachedData).includes(prop)) : null;
            // return without any worries
            if (!uniqueProps || uniqueProps.length <= 1) {
                return cachedData;
            }
        }
    }
    let apiString = `/groups/${id}`;
    if (requestedProps) {
        apiString = apiString + '?$select=' + requestedProps.toString();
    }
    // else we must grab it
    const response = (yield graph.api(apiString).middlewareOptions(prepScopes(scopes)).get());
    if (getIsGroupsCacheEnabled()) {
        yield cache.putValue(id, { group: JSON.stringify(response) });
    }
    return response;
});
/**
 * Returns a Promise of Graph Groups array associated with the groupIds array
 *
 * @export
 * @param {IGraph} graph
 * @param {string[]} groupIds, an array of string ids
 * @returns {Promise<Group[]>}
 */
export const getGroupsForGroupIds = (graph, groupIds, filters = '') => __awaiter(void 0, void 0, void 0, function* () {
    if (!groupIds || groupIds.length === 0) {
        return [];
    }
    const batch = graph.createBatch();
    const groupDict = {};
    const notInCache = [];
    let cache;
    if (getIsGroupsCacheEnabled()) {
        cache = CacheService.getCache(schemas.groups, schemas.groups.stores.groups);
    }
    for (const id of groupIds) {
        groupDict[id] = null;
        let group;
        if (getIsGroupsCacheEnabled()) {
            group = yield cache.getValue(id);
        }
        if (group && getGroupsInvalidationTime() > Date.now() - group.timeCached) {
            groupDict[id] = group.group ? JSON.parse(group.group) : null;
        }
        else if (id !== '') {
            let apiUrl = `/groups/${id}`;
            if (filters) {
                apiUrl = `${apiUrl}?$filters=${filters}`;
            }
            batch.get(id, apiUrl, ['Group.Read.All']);
            notInCache.push(id);
        }
    }
    try {
        const responses = yield batch.executeAll();
        // iterate over groupIds to ensure the order of ids
        for (const id of groupIds) {
            const response = responses.get(id);
            if (response === null || response === void 0 ? void 0 : response.content) {
                groupDict[id] = response.content;
                if (getIsGroupsCacheEnabled()) {
                    yield cache.putValue(id, { group: JSON.stringify(response.content) });
                }
            }
        }
        return Promise.all(Object.values(groupDict));
    }
    catch (_) {
        // fallback to making the request one by one
        try {
            // call getGroup for all the users that weren't cached
            groupIds
                .filter(id => notInCache.includes(id))
                .forEach(id => {
                groupDict[id] = getGroup(graph, id);
            });
            if (getIsGroupsCacheEnabled()) {
                // store all users that weren't retrieved from the cache, into the cache
                yield Promise.all(groupIds
                    .filter(id => notInCache.includes(id))
                    .map((id) => __awaiter(void 0, void 0, void 0, function* () { return yield cache.putValue(id, { group: JSON.stringify(yield groupDict[id]) }); })));
            }
            return Promise.all(Object.values(groupDict));
        }
        catch (e) {
            return [];
        }
    }
});
/**
 * Gets groups from the graph that are in the group ids
 *
 * @param graph
 * @param query
 * @param groupId
 * @param top
 * @param transitive
 * @param groupTypes
 * @param filters
 * @returns
 */
export const findGroupsFromGroupIds = (graph, query, groupIds, top = 10, groupTypes = GroupType.any, filters = '') => __awaiter(void 0, void 0, void 0, function* () {
    const foundGroups = [];
    const graphGroups = yield findGroups(graph, query, top, groupTypes, filters);
    if (graphGroups) {
        for (const group of graphGroups) {
            if (group.id && groupIds.includes(group.id)) {
                foundGroups.push(group);
            }
        }
    }
    return foundGroups;
});
//# sourceMappingURL=graph.groups.js.map